{
  "title": "Seidel's algorithm",
  "summary": "Seidel's algorithm is an algorithm designed by Raimund Seidel in 1992 for the all-pairs-shortest-path problem for undirected, unweighted, connected graphs. It solves the problem in \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            ω\n          \n        \n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{\\omega }\\log V)}\n  \n expected time for a graph with \n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n vertices, where \n  \n   ",
  "content": "---\ntitle: Seidel's algorithm\nurl: https://en.wikipedia.org/wiki/Seidel%27s_algorithm\nlanguage: en\ncategories: [\"Category:Articles with example Python (programming language) code\", \"Category:Computational problems in graph theory\", \"Category:Graph algorithms\", \"Category:Graph distance\", \"Category:Polynomial-time problems\"]\nreferences: 0\nlast_modified: 2024-11-26T20:30:40Z\n---\n\n# Seidel's algorithm\n\n## Summary\n\nSeidel's algorithm is an algorithm designed by Raimund Seidel in 1992 for the all-pairs-shortest-path problem for undirected, unweighted, connected graphs. It solves the problem in \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            ω\n          \n        \n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{\\omega }\\log V)}\n  \n expected time for a graph with \n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n vertices, where \n  \n   \n\n## Full Content\n\nSeidel's algorithm is an algorithm designed by Raimund Seidel in 1992 for the all-pairs-shortest-path problem for undirected, unweighted, connected graphs. It solves the problem in \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            ω\n          \n        \n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{\\omega }\\log V)}\n  \n expected time for a graph with \n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n vertices, where \n  \n    \n      \n        ω\n        <\n        2.373\n      \n    \n    {\\displaystyle \\omega <2.373}\n  \n is the exponent in the complexity \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            ω\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{\\omega })}\n  \n of \n  \n    \n      \n        n\n        ×\n        n\n      \n    \n    {\\displaystyle n\\times n}\n  \n matrix multiplication. If only the distances between each pair of vertices are sought, the same time bound can be achieved in the worst case. Even though the algorithm is designed for connected graphs, it can be applied individually to each connected component of a graph with the same running time overall. There is an exception to the expected running time given above for computing the paths: if \n  \n    \n      \n        ω\n        =\n        2\n      \n    \n    {\\displaystyle \\omega =2}\n  \n the expected running time becomes \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            2\n          \n        \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{2}\\log ^{2}V)}\n  \n.\n\nDetails of the implementation\nThe core of the algorithm is a procedure that computes the length of the shortest-paths between any pair of vertices.\nIn the worst case this can be done in \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            ω\n          \n        \n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{\\omega }\\log V)}\n  \n time. Once the lengths are computed, the paths can be reconstructed using a Las Vegas algorithm whose expected running time is \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            ω\n          \n        \n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{\\omega }\\log V)}\n  \n for \n  \n    \n      \n        ω\n        >\n        2\n      \n    \n    {\\displaystyle \\omega >2}\n  \n and \n  \n    \n      \n        O\n        (\n        \n          V\n          \n            2\n          \n        \n        \n          log\n          \n            2\n          \n        \n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(V^{2}\\log ^{2}V)}\n  \n for \n  \n    \n      \n        ω\n        =\n        2\n      \n    \n    {\\displaystyle \\omega =2}\n  \n.\n\nComputing the shortest-paths lengths\nThe Python code below assumes the input graph is given as a \n  \n    \n      \n        n\n        ×\n        n\n      \n    \n    {\\displaystyle n\\times n}\n  \n \n  \n    \n      \n        0\n      \n    \n    {\\displaystyle 0}\n  \n-\n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n adjacency matrix \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n with zeros on the diagonal. It defines the function APD which returns a matrix with entries \n  \n    \n      \n        \n          D\n          \n            i\n            ,\n            j\n          \n        \n      \n    \n    {\\displaystyle D_{i,j}}\n  \n such that \n  \n    \n      \n        \n          D\n          \n            i\n            ,\n            j\n          \n        \n      \n    \n    {\\displaystyle D_{i,j}}\n  \n is the length of the shortest path between the vertices \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n and \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n. The matrix class used can be any matrix class implementation supporting the multiplication, exponentiation, and indexing operators (for example numpy.matrix).\n\nThe base case tests whether the input adjacency matrix describes a complete graph, in which case all shortest paths have length \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n.\n\nGraphs with weights from finite universes\nAlgorithms for undirected and directed graphs with weights from a finite universe \n  \n    \n      \n        {\n        1\n        ,\n        …\n        ,\n        M\n        ,\n        +\n        ∞\n        }\n      \n    \n    {\\displaystyle \\{1,\\ldots ,M,+\\infty \\}}\n  \n also exist. The best known algorithm for the directed case is in time \n  \n    \n      \n        \n          \n            \n              O\n              ~\n            \n          \n        \n        (\n        \n          M\n          \n            1\n            \n              /\n            \n            (\n            4\n            −\n            ω\n            )\n          \n        \n        \n          V\n          \n            2\n            +\n            1\n            \n              /\n            \n            (\n            4\n            −\n            ω\n            )\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\tilde {O}}(M^{1/(4-\\omega )}V^{2+1/(4-\\omega )})}\n  \n by Zwick in 1998. This algorithm uses rectangular matrix multiplication instead of square matrix multiplication. Better upper bounds can be obtained if one uses the best rectangular matrix multiplication algorithm available instead of achieving rectangular multiplication via multiple square matrix multiplications. The best known algorithm for the undirected case is in time \n  \n    \n      \n        \n          \n            \n              O\n              ~\n            \n          \n        \n        (\n        M\n        \n          V\n          \n            ω\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\tilde {O}}(MV^{\\omega })}\n  \n by Shoshan and Zwick in 1999. The original implementation of this algorithm was erroneous and has been corrected by Eirinakis, Williamson, and Subramani in 2016.\n\n\n== Notes ==\n",
  "categories": [
    "Category:Articles with example Python (programming language) code",
    "Category:Computational problems in graph theory",
    "Category:Graph algorithms",
    "Category:Graph distance",
    "Category:Polynomial-time problems"
  ],
  "archived_date": "20241220_214812",
  "source_url": "https://en.wikipedia.org/wiki/Seidel%27s_algorithm"
}