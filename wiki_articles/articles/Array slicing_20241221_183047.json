{
  "title": "Array slicing",
  "summary": "In computer programming, array slicing is an operation that extracts a subset of elements from an array and packages them as another array, possibly in a different dimension from the original. \nCommon examples of array slicing are extracting a substring from a string of characters, the \"ell\" in \"hello\", extracting a row or column from a two-dimensional array, or extracting a vector from a matrix.\nDepending on the programming language, an array slice can be made out of non-consecutive elements.  ",
  "content": "---\ntitle: Array slicing\nurl: https://en.wikipedia.org/wiki/Array_slicing\nlanguage: en\ncategories: [\"Category:Arrays\", \"Category:Articles with example ALGOL 68 code\", \"Category:Articles with example Ada code\", \"Category:Articles with example BASIC code\", \"Category:Articles with example D code\", \"Category:Articles with example Fortran code\", \"Category:Articles with example Perl code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:Programming constructs\", \"Category:Short description is different from Wikidata\"]\nreferences: 0\nlast_modified: 2024-12-19T13:45:11Z\n---\n\n# Array slicing\n\n## Summary\n\nIn computer programming, array slicing is an operation that extracts a subset of elements from an array and packages them as another array, possibly in a different dimension from the original. \nCommon examples of array slicing are extracting a substring from a string of characters, the \"ell\" in \"hello\", extracting a row or column from a two-dimensional array, or extracting a vector from a matrix.\nDepending on the programming language, an array slice can be made out of non-consecutive elements.  \n\n## Full Content\n\nIn computer programming, array slicing is an operation that extracts a subset of elements from an array and packages them as another array, possibly in a different dimension from the original. \nCommon examples of array slicing are extracting a substring from a string of characters, the \"ell\" in \"hello\", extracting a row or column from a two-dimensional array, or extracting a vector from a matrix.\nDepending on the programming language, an array slice can be made out of non-consecutive elements.  Also depending on the language, the elements of the new array may be aliased to (i.e., share memory with) those of the original array.\n\nDetails\nFor \"one-dimensional\" (single-indexed) arrays –  vectors, sequence, strings etc. –  the most common slicing operation is extraction of zero or more consecutive elements. Thus, if we have a vector containing elements (2, 5, 7, 3, 8, 6, 4, 1), and we want to create an array slice from the 3rd to the 6th items, we get (7, 3, 8, 6). In programming languages that use a 0-based indexing scheme, the slice would be from index 2 to 5.\nReducing the range of any index to a single value effectively eliminates that index. This feature can be used, for example, to extract one-dimensional slices (vectors: in 3D, rows, columns, and tubes) or two-dimensional slices (rectangular matrices) from a  three-dimensional array. However, since the range can be specified at run-time, type-checked languages may require an explicit (compile-time) notation to actually eliminate the trivial indices.\nGeneral array slicing can be implemented (whether or not built into the language) by referencing every array through a dope vector or descriptor –  a record that contains the address of the first array element, and then the range of each index and the corresponding coefficient in the indexing formula. This technique also allows immediate array transposition, index reversal, subsampling, etc. For languages like C, where the indices always start at zero, the dope vector of an array with d indices has at least 1 + 2d parameters. For languages that allow arbitrary lower bounds for indices, like Pascal, the dope vector needs 1 + 3d entries.\nIf the array abstraction does not support true negative indices (as for example the arrays of Ada and Pascal do), then negative indices for the bounds of the slice for a given dimension are sometimes used to specify an offset from the end of the array in that dimension. In 1-based schemes, -1 generally would indicate the second-to-last item, while in a 0-based system, it would mean the very last item.\n\nHistory\nThe concept of slicing was surely known even before the invention of compilers. Slicing as a language feature probably started with FORTRAN (1957), more as a consequence of non-existent type and range checking than by design. The concept was also alluded to in the preliminary report for the IAL (ALGOL 58) in that the syntax allowed one or more indices of an array element (or, for that matter, of a procedure call) to be omitted when used as an actual parameter.\nKenneth Iverson's APL (1957) had very flexible multi-dimensional array slicing, which contributed much to the language's expressive power and popularity.\nALGOL 68 (1968) introduced comprehensive multi-dimension array slicing and trimming features.\nArray slicing facilities have been incorporated in several modern languages, such as Ada 2005, Cobra, D, Fortran 90, Go, Rust, Julia, MATLAB, Perl, Python, S-Lang, Windows PowerShell and the mathematical/statistical languages GNU Octave, S and R.\n\nTimeline of slicing in various programming languages\n1964: PL/I\nPL/I provides two facilities for array slicing.\n\nUsing iSub DEFINING, an array slice can be declared using iSUB variables to map specific elements in a \"base array\" onto elements of the \"defined array\". iSUBs can define rows, columns, diagonals, or many-to-one mappings.: pp.212–213  The following example defines Y as a one-dimensional slice consisting of the diagonal elements of the two-dimensional array X.\nDECLARE X(5,5);\nDECLARE Y(5) DEFINED(X(1SUB,1SUB));\nA reference to Y(2) is a reference to X(2,2), and so on.\n\nA slice, called a cross-section, of an array can be referred to by using asterisk as the subscript for one or more dimensions. The following code sets all the elements in the first column of X to zero. One or more subscripts can be specified by asterisks in an expression.: p.43 \nDECLARE X(5,5);\nX(*,1)=0;\n\n1966: Fortran 66\nThe Fortran 66 programmers were only able to take advantage of slicing matrices by row, and then only when passing that row to a subroutine:\n\nResult:\n\n   2.000000       4.000000       8.000000\n\nNote that there is no dope vector in FORTRAN 66 hence the length of the slice must also be passed as an argument - or some other means - to the SUBROUTINE. 1970s Pascal and C had similar restrictions.\n\n1968: Algol 68\nAlgol68 final report contains an early example of slicing, slices are specified in the form:\n\n[lower bound:upper bound] ¢ for computers with extended character sets ¢\n\nor:\n\n(LOWER BOUND..UPPER BOUND) # FOR COMPUTERS WITH ONLY 6 BIT CHARACTERS. #\n\nBoth bounds are inclusive and can be omitted, in which case they default to the declared array bounds. Neither the stride facility, nor diagonal slice aliases are part of the revised report.\nExamples:\n\n[3, 3]real a := ((1, 1, 1), (2, 4, 8), (3, 9, 27)); # declaration of a variable matrix #\n[,]  real c = ((1, 1, 1), (2, 4, 8), (3, 9, 27));   # constant matrix, the size is implied #\n\nref[]real row := a[2,];                    # alias/ref to a row slice #\nref[]real col2 = a[, 2];                   # permanent alias/ref to second column #\n\nprint ((a[:, 2], newline));                # second column slice #\nprint ((a[1⌈a, :], newline));              # last row slice #\nprint ((a[:, 2⌈a], newline));              # last column slice #\nprint ((a[:2, :2], newline));              # leading 2-by-2 submatrix \"slice\" #\n\n+1.000010+0 +4.000010+0 +9.000010+0\n+3.000010+0 +9.000010+0 +2.700010+1\n+1.000010+0 +8.000010+0 +2.700010+1\n+1.000010+0 +1.000010+0 +2.000010+0 +4.000010+0\n\n1968: BASIC\nHP's HP 2000 systems, introduced in November 1968, used HP Time-Shared BASIC as their primary interface and programming language. This version of BASIC used slicing for most string manipulation operations. One oddity of the language was that it allowed round or square braces interchangeably, and which was used in practice was typically a function of the computer terminal being used.\nExample:\n\nWill produce:\n\nHELLO\nWORLD\n\nThe HP systems were widely used in the early 1970s, especially in technical high schools and many small industrial and scientific settings. As the first microcomputers emerged in the mid-1970s, HP was often used as the pattern for their BASIC dialects as well. Notable examples include 1977's Apple BASIC, 1978's Atari BASIC, and 1979's Sinclair BASIC. This style of manipulation generally offers advantages in terms of memory use, and was often chosen on systems that shipped with small amounts of memory. Only Sinclair's dialect differed in any meaningful way, using the TO keyword instead of a comma-separated list:\n\nSlicing was also selected as the basis for the ANSI Full BASIC standard, using the colon as the separator and thus differentiating between slicing and array access:\n\nWhile this style of access offered a number of advantages, especially for the small machines of the era, sometime after 1970 Digital Equipment Corporation introduced their own variation of BASIC that used the LEFT$, RIGHT$ and MID$ string functions. Microsoft BASIC was written on the PDP-10 and its BASIC was used as the pattern. Through the late 1970s the two styles were both widely used, but by the early 1980s the DEC-style functions were the de facto standard.\n\n1970s: MATLAB\nThe : operator implements the stride syntax (lower_bound:upper_bound[:stride]) by generating a vector. 1:5 evaluates as [1, 2, 3, 4, 5]. 1:9:2 evaluates as [1, 3, 5, 7, 9]. A bare : evaluates the same as 1:end, with end determined by context.\n\n1976: S/R\nArrays in S and GNU R are always one-based, thus the indices of a new slice will begin with one for each dimension, regardless of the previous indices. Dimensions with length of one will be dropped (unless drop = FALSE). Dimension names (where present) will be preserved.\n\n1977: Fortran 77\nThe Fortran 77 standard introduced the ability to slice and concatenate strings:\n\nProduces:\n\nBCD\n\nSuch strings could be passed by reference to another subroutine, the length would also be passed transparently to the subroutine as a kind of short dope vector.\n\nAgain produces:\n\nBCD\n\n1983: Ada 83 and above\nAda 83 supports slices for all array types. Like Fortran 77 such arrays could be passed by reference to another subroutine, the length would also be passed transparently to the subroutine as a kind of short dope vector.\n\nProduces:\n\nBCD\n\nNote: Since in Ada indices are n-based the term Text (2 .. 4) will result in an Array with the base index of 2.\nThe definition for Text_IO.Put_Line is:\n\nThe definition for String is:\n\nAs Ada supports true negative indices as in type History_Data_Array is array (-6000 .. 2010) of History_Data; it places no special meaning on negative indices. In the example above the term  Some_History_Data (-30 .. 30) would slice the History_Data from 31 BC to 30 AD (since there was no year zero, the year number 0 actually refers to 1 BC).\n\n1987: Perl\nIf we have\n\nas above, then the first 3 elements, middle 3 elements and last 3 elements would be:\n\nPerl supports negative list indices. The -1 index is the last element, -2 the penultimate element, etc.\nIn addition, Perl supports slicing based on expressions, for example:\n\n1991: Python\nIf you have the following list:\n\nThen it is possible to slice by using a notation similar to element retrieval:\n\nNote that Python allows negative list indices. The index -1 represents the last element, -2 the penultimate element, etc.\nPython also allows a step property by appending an extra colon and a value. For example:\n\nThe stride syntax (nums[1:5:2]) was introduced in the second half of the 1990s, as a result of requests put forward by scientific users in the Python \"matrix-SIG\" (special interest group).\nSlice semantics potentially differ per object; new semantics can be introduced when operator overloading the indexing operator. With Python standard lists (which are dynamic arrays), every slice is a copy. Slices of NumPy arrays, by contrast, are views onto the same underlying buffer.\n\n1992: Fortran 90 and above\nIn Fortran 90, slices are specified in the form\n\nBoth bounds are inclusive and can be omitted, in which case they default to the declared\narray bounds. Stride defaults to 1. Example:\n\n1994: Analytica\nEach dimension of an array value in Analytica is identified by an Index variable. When slicing or subscripting, the syntax identifies the dimension(s) over which you are slicing or subscripting by naming the dimension. Such as:\n\nIndex I := 1..5   { Definition of a numerical Index }\nIndex J := ['A', 'B', 'C'] { Definition of a text-valued Index }\nVariable X := Array(I, J, [[10, 20, 30], [1, 2, 3], ....]) { Definition of a 2D value }\nX[I = 1, J = 'B']  -> 20  { Subscript to obtain a single value }\nX[I = 1] ->  Array(J, [10, 20, 30])  { Slice out a 1D array. }\nX[J = 2] -> Array(I, [20, 2, ....]) { Slice out a 1D array over the other dimension. }\nX[I = 1..3]  {Slice out first four elements over I with all elements over J}\n\nNaming indexes in slicing and subscripting is similar to naming parameters in function calls instead of relying on a fixed sequence of parameters. One advantage of naming indexes in slicing is that the programmer does not have to remember the sequence of Indexes, in a multidimensional array. A deeper advantage is that expressions generalize automatically and safely without requiring a rewrite when the number of dimensions of X changes.\n\n1998: S-Lang\nArray slicing was introduced in version 1.0. Earlier versions did not\nsupport this feature.\nSuppose that A is a 1-d array such as\n\n    A = [1:50];           % A = [1, 2, 3, ...49, 50]\n\nThen an array B of first 5 elements of A may be created using\n\n    B = A[[:4]];\n\nSimilarly, B may be assigned to an array of the last 5 elements of A via:\n\n    B = A[[-5:]];\n\nOther examples of 1-d slicing include:\n\n    A[-1]                 % The last element of A\n    A[*]                  % All elements of A\n    A[[::2]]              % All even elements of A\n    A[[1::2]]             % All odd elements of A\n    A[[-1::-2]]           % All even elements in the reversed order\n    A[[[0:3], [10:14]]]   % Elements 0-3 and 10-14\n\nSlicing of higher-dimensional arrays works similarly:\n\n    A[-1, *]              % The last row of A\n    A[[1:5], [2:7]]       % 2d array using rows 1-5 and columns 2-7\n    A[[5:1:-1], [2:7]]    % Same as above except the rows are reversed\n\nArray indices can also be arrays of integers. For example, suppose\nthat I = [0:9] is an array of 10 integers. Then\nA[I] is equivalent to an array of the first 10 elements\nof A. A practical example of this is a sorting\noperation such as:\n\n    I = array_sort(A);    % Obtain a list of sort indices\n    B = A[I];             % B is the sorted version of A\n    C = A[array_sort(A)]; % Same as above but more concise.\n\n1999: D\nConsider the array:\n\nTake a slice out of it:\n\nand the contents of b will be [7, 3, 8]. The first index of the slice is inclusive, the second is exclusive.\n\nmeans that the dynamic array c now contains [8, 6] because inside the [] the $ symbol refers to the length of the array.\nD array slices are aliased to the original array, so:\n\nmeans that a now has the contents [2, 5, 7, 3, 10, 6, 4, 1]. To create a copy of the array data, instead of only an alias, do:\n\nUnlike Python, D slice bounds don't saturate, so code equivalent to this Python code is an error in D:\n\n2004: SuperCollider\nThe programming language SuperCollider implements some concepts from J/APL. Slicing looks as follows:\n\n2005: fish\nArrays in fish are always one-based, thus the indices of a new slice will begin with one, regardless of the previous indices.\n\n2006: Cobra\nCobra supports Python-style slicing. If you have a list\n\nthen the first 3 elements, middle 3 elements, and last 3 elements would be:\n\nCobra also supports slicing-style syntax for 'numeric for loops':\n\n2006: Windows PowerShell\nArrays are zero-based in PowerShell and can be defined using the comma operator:\n\n2009: Go\nGo supports Python-style syntax for slicing (except negative indices are not supported). Arrays and slices can be sliced. If you have a slice\n\nthen the first 3 elements, middle 3 elements, last 3 elements, and a copy of the entire slice would be:\n\nSlices in Go are reference types, which means that different slices may refer to the same underlying array.\n\n2010: Cilk Plus\nCilk Plus supports syntax for array slicing as an extension to C and C++.\n\nCilk Plus slicing looks as follows:\n\nCilk Plus's array slicing differs from Fortran's in two ways:\n\nthe second parameter is the length (number of elements in the slice) instead of the upper bound, in order to be consistent with standard C libraries;\nslicing never produces a temporary, and thus never needs to allocate memory. Assignments are required to be either non-overlapping or perfectly overlapping, otherwise the result is undefined.\n\n2012: Julia\nJulia array slicing is like that of MATLAB, but uses square brackets.  Example:\n\nSee also\nComparison of programming languages (array) § Slicing\n\n\n== References ==\n",
  "categories": [
    "Category:Arrays",
    "Category:Articles with example ALGOL 68 code",
    "Category:Articles with example Ada code",
    "Category:Articles with example BASIC code",
    "Category:Articles with example D code",
    "Category:Articles with example Fortran code",
    "Category:Articles with example Perl code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:Programming constructs",
    "Category:Short description is different from Wikidata"
  ],
  "archived_date": "20241221_183047",
  "source_url": "https://en.wikipedia.org/wiki/Array_slicing"
}