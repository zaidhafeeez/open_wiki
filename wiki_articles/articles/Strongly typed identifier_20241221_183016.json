{
  "title": "Strongly typed identifier",
  "summary": "A strongly typed identifier is user-defined data type which serves as an identifier or key that is strongly typed. This is a solution to the \"primitive obsession\" code smell as mentioned by Martin Fowler. The data type should preferably be immutable if possible. It is common for implementations to handle equality testing, serialization and model binding.\nThe strongly typed identifier commonly wraps the data type used as the primary key in the database, such as a string, an integer or universally",
  "content": "---\ntitle: Strongly typed identifier\nurl: https://en.wikipedia.org/wiki/Strongly_typed_identifier\nlanguage: en\ncategories: [\"Category:Articles with example C++ code\", \"Category:Articles with example C Sharp code\", \"Category:Articles with example D code\", \"Category:Articles with example Haskell code\", \"Category:Articles with example JavaScript code\", \"Category:Articles with example Java code\", \"Category:Articles with example Julia code\", \"Category:Articles with example PHP code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with example Ruby code\", \"Category:Articles with example Rust code\", \"Category:Articles with example Scala code\", \"Category:Articles with example Swift code\", \"Category:Data types\", \"Category:Software design patterns\"]\nreferences: 0\nlast_modified: 2024-10-30T13:34:56Z\n---\n\n# Strongly typed identifier\n\n## Summary\n\nA strongly typed identifier is user-defined data type which serves as an identifier or key that is strongly typed. This is a solution to the \"primitive obsession\" code smell as mentioned by Martin Fowler. The data type should preferably be immutable if possible. It is common for implementations to handle equality testing, serialization and model binding.\nThe strongly typed identifier commonly wraps the data type used as the primary key in the database, such as a string, an integer or universally\n\n## Full Content\n\nA strongly typed identifier is user-defined data type which serves as an identifier or key that is strongly typed. This is a solution to the \"primitive obsession\" code smell as mentioned by Martin Fowler. The data type should preferably be immutable if possible. It is common for implementations to handle equality testing, serialization and model binding.\nThe strongly typed identifier commonly wraps the data type used as the primary key in the database, such as a string, an integer or universally unique identifier (UUID).\nWeb frameworks can often be configured to model bind properties on view models that are strongly typed identifiers. Objectâ€“relational mappers can often be configured with value converters to map data between the properties on a model using strongly typed identifier data types and database columns.\n\nExamples\nPassing a strongly typed identifier throughout the layers of an example application.\n\nC#\nC# have records which provide immutability and equality testing. The record is sealed to prevent inheritance. It overrides the built-in ToString() method.\nThis example implementation includes a static method which can be used to initialize a new instance with a randomly generated globally unique identifier (GUID).\n\nC++\nC++ have structs but not immutability so here the id field is marked as private with a method named value() to get the value.\n\nCrystal\nCrystal's standard library provides the record macro for creating records which are immutable structs and lets you create override the built-in to_s method.\n\nD\nD have immutable structs.\n\nDart\nDart have classes with operator overloading.\n\nF#\nF# lets you create override the Equals, GetHashCode and ToString methods.\n\nGo\nGo have structs which provide equality testing. Go however does not provide immutability.\n\nGroovy\nGroovy have record classes which provide immutability and equality testing.\n\nHaskell\nHaskell can create user-defined custom data types using the newtype keyword. It provides equality testing using the Eq standard class and printing using the Read and Show standard classes.\n\nJava\nJava have records which provide equality testing.\nThe record is declared using the final modifier keyword to prevent inheritance. It overrides the built-in toString() method.\n\nJavaScript\nThis JavaScript example implementation provides the toJSON method used by the JSON.stringify() function to serialize the class into a simple string instead of a composite data type.\nIt calls Object.freeze() to make the instance immutable.\nIt overrides the built-in toString() method and the valueOf() method.\n\nJulia\nJulia have immutable composite data types.\n\nKotlin\nKotlin have \"inline classes\".\n\nNim\nNim have \"distinct types\".\n\nPHP\nThis PHP example implementation implements the __toString() magic method.\nFurthermore, it implements the JsonSerializable interface which is used by the built-in json_encode function to serialize the class into a simple string instead of a composite data type.\nThe class is declared using the final modifier keyword to prevent inheritance.\nPHP has traits as a way to re-use code.\n\nPython\nPython has data classes which provides equality testing and can be made immutable using the frozen parameter. It overrides the __str__ dunder method.\nThis example implementation includes a static method which can be used to initialize a new instance with a randomly generated universally unique identifier (UUID).\n\nPython also has NewType which can be used to create new data types.\n\nRuby\nRuby have data classes which provides equality testing and are immutable. It overrides the built-in to_s method.\nThis example implementation includes a static method which can be used to initialize a new instance with a randomly generated universally unique identifier (UUID).\n\nRust\nIn Rust this can be done using a tuple struct containing a single value. This example implementation implements the Debug and the PartialEq traits. The PartialEq trait provides equality testing.\n\nScala\nScala have case classes which provide immutability and equality testing. The case class is sealed to prevent inheritance.\n\nSwift\nSwift have the CustomStringConvertible protocol which can be used to provide its own representation to be used when converting an instance to a string, and the Equatable protocol which provides equality testing.\n\nZig\nZig have structs with constants but by design does not have operator overloading and method overriding.\n\nSee also\nDomain-driven design\nType safety\nValue object\n\nReferences\nExternal links\nhttps://wiki.c2.com/?PrimitiveObsession\n",
  "categories": [
    "Category:Articles with example C++ code",
    "Category:Articles with example C Sharp code",
    "Category:Articles with example D code",
    "Category:Articles with example Haskell code",
    "Category:Articles with example JavaScript code",
    "Category:Articles with example Java code",
    "Category:Articles with example Julia code",
    "Category:Articles with example PHP code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with example Ruby code",
    "Category:Articles with example Rust code",
    "Category:Articles with example Scala code",
    "Category:Articles with example Swift code",
    "Category:Data types",
    "Category:Software design patterns"
  ],
  "archived_date": "20241221_183016",
  "source_url": "https://en.wikipedia.org/wiki/Strongly_typed_identifier"
}