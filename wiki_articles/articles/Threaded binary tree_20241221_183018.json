{
  "title": "Threaded binary tree",
  "summary": "In computing, a threaded binary tree is a binary tree variant that facilitates traversal in a particular order.\nAn entire binary search tree can be easily traversed in order of the main key, but given only a pointer to a node, finding the node which comes next may be slow or impossible. For example, leaf nodes by definition have no descendants, so given only a pointer to a leaf node no other node can be reached. A threaded tree adds extra information in some or all nodes, so that for any given s",
  "content": "---\ntitle: Threaded binary tree\nurl: https://en.wikipedia.org/wiki/Threaded_binary_tree\nlanguage: en\ncategories: [\"Category:All articles needing rewrite\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:Binary trees\", \"Category:Search trees\", \"Category:Short description is different from Wikidata\", \"Category:Wikipedia articles needing rewrite from October 2011\"]\nreferences: 0\nlast_modified: 2024-12-19T13:54:18Z\n---\n\n# Threaded binary tree\n\n## Summary\n\nIn computing, a threaded binary tree is a binary tree variant that facilitates traversal in a particular order.\nAn entire binary search tree can be easily traversed in order of the main key, but given only a pointer to a node, finding the node which comes next may be slow or impossible. For example, leaf nodes by definition have no descendants, so given only a pointer to a leaf node no other node can be reached. A threaded tree adds extra information in some or all nodes, so that for any given s\n\n## Full Content\n\nIn computing, a threaded binary tree is a binary tree variant that facilitates traversal in a particular order.\nAn entire binary search tree can be easily traversed in order of the main key, but given only a pointer to a node, finding the node which comes next may be slow or impossible. For example, leaf nodes by definition have no descendants, so given only a pointer to a leaf node no other node can be reached. A threaded tree adds extra information in some or all nodes, so that for any given single node the \"next\" node can be found quickly, allowing tree traversal without recursion and the extra storage (proportional to the tree's depth) that recursion requires.\n\nThreading\n\"A binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node.\"\n\nThis assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called \"threads\", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.\n\nMotivation\nTrees, including (but not limited to) binary search trees, can be used to store items in a particular order, such as the value of some property stored in each node, often called a key. One useful operation on such a tree is traversal: visiting all the items in order of the key.\nA simple recursive traversal algorithm that visits each node of a binary search tree is the following. Assume t is a pointer to a node, or nil. \"Visiting\" t can mean performing any action on the node t or its contents.\n\nOne problem with this algorithm is that, because of its recursion, it uses stack space proportional to the height of a tree. If the tree is fairly balanced, this amounts to O(log n) space for a tree containing n elements. In the worst case, when the tree takes the form of a chain, the height of the tree is n so the algorithm takes O(n) space. A second problem is that all traversals must begin at the root when nodes have pointers only to their children. It is common to have a pointer to a particular node, but that is not sufficient to get back to the rest of the tree unless extra information is added, such as thread pointers.\nIn this approach, it may not be possible to tell whether the left and/or right pointers in a given node actually point to children, or are a consequence of threading. If the distinction is necessary, adding a single bit to each node is enough to record it.\nIn a 1968 textbook, Donald Knuth asked whether a non-recursive algorithm for in-order traversal exists, that uses no stack and leaves the tree unmodified. One of the solutions to this problem is tree threading, presented by Joseph M. Morris in 1979.\nIn the 1969 follow-up edition, Knuth attributed the threaded tree representation to Perlis and Thornton (1960).\n\nRelation to parent pointers\nAnother way to achieve similar goals is to include a pointer in every node, to that node's parent node. Given that, the \"next\" node can always be reached, \"right\" pointers are still null whenever there are no right children. To find the \"next\" node from a node whose right pointer is null, walk up through \"parent\" pointers until reaching a node whose right pointer is not null, and is not the child you just came up from. That node is the \"next\" node, and after it come its descendants on the right.\nIt is also possible to discover the parent of a node from a threaded binary tree, without explicit use of parent pointers or a stack, although it is slower. To see this, consider a node k with right child r.  Then the left pointer of r must be either a child or a thread back to k. In the case that r has a left child, that left child must in turn have either a left child of its own or a thread back to k, and so on for all successive left children.  So by following the chain of left pointers from r, we will eventually find a thread pointing back to k.  The situation is symmetrically similar when q is the left child of p—we can follow q's right children to a thread pointing ahead to p.\n\nIn Python:\n\nTypes\nSingle threaded: each node is threaded towards either the in-order predecessor or successor (left or right).\nDouble threaded: each node is threaded towards both the in-order predecessor and successor (left and right).\n\nThe array of in-order traversal\nThreads are reference to the predecessors and successors of the node according to an inorder traversal. \nIn-order traversal of the threaded tree is A,B,C,D,E,F,G,H,I, the predecessor of E is D, the successor of E is F.\n\nExample\nLet's make the Threaded Binary tree out of a normal binary tree:\n\nThe in-order traversal for the above tree is — D B A E C. So, the respective Threaded Binary tree will be --\n\nNull links\nIn an m-way threaded binary tree with n nodes, there are n×m − (n−1) void links.\n\nReferences\nExternal links\nGNU libavl 2.0.2, Section on threaded binary search trees\n",
  "categories": [
    "Category:All articles needing rewrite",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:Binary trees",
    "Category:Search trees",
    "Category:Short description is different from Wikidata",
    "Category:Wikipedia articles needing rewrite from October 2011"
  ],
  "archived_date": "20241221_183018",
  "source_url": "https://en.wikipedia.org/wiki/Threaded_binary_tree"
}