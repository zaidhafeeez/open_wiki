{
  "title": "Uniform access principle",
  "summary": "The uniform access principle of computer programming was put forth by Bertrand Meyer (originally in his book Object-Oriented Software Construction). It states \"All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.\" This principle applies generally to the syntax of object-oriented programming languages. In simpler form, it states that there should be no syntactical difference betw",
  "content": "---\ntitle: Uniform access principle\nurl: https://en.wikipedia.org/wiki/Uniform_access_principle\nlanguage: en\ncategories: [\"Category:All Wikipedia articles written in American English\", \"Category:All articles needing additional references\", \"Category:All articles with style issues\", \"Category:Articles needing additional references from January 2010\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:Programming paradigms\", \"Category:Programming principles\", \"Category:Short description matches Wikidata\", \"Category:Software design\", \"Category:Use American English from March 2019\", \"Category:Wikipedia articles with style issues from December 2024\"]\nreferences: 0\nlast_modified: 2024-12-19T18:29:06Z\n---\n\n# Uniform access principle\n\n## Summary\n\nThe uniform access principle of computer programming was put forth by Bertrand Meyer (originally in his book Object-Oriented Software Construction). It states \"All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.\" This principle applies generally to the syntax of object-oriented programming languages. In simpler form, it states that there should be no syntactical difference betw\n\n## Full Content\n\nThe uniform access principle of computer programming was put forth by Bertrand Meyer (originally in his book Object-Oriented Software Construction). It states \"All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.\" This principle applies generally to the syntax of object-oriented programming languages. In simpler form, it states that there should be no syntactical difference between working with an attribute, pre-computed property, or method/query of an object.\nWhile most examples focus on the \"read\" aspect of the principle (i.e., retrieving a value), Meyer shows that the \"write\" implications (i.e., modifying a value) of the principle are harder to deal with in his monthly column on the Eiffel programming language official website.\n\nExplanation\nThe problem being addressed by Meyer involves the maintenance of large software projects or software libraries. Sometimes when developing or maintaining software it is necessary, after much code is in place, to change a class or object in a way that transforms what was simply an attribute access into a method call.  Programming languages often use different syntax for attribute access and invoking a method, (e.g., object.something versus object.something()). The syntax change would require, in popular programming languages of the day, changing the source code in all the places where the attribute was used.  This might require changing source code in many different locations throughout a very large volume of source code. Or worse, if the change is in an object library used by hundreds of customers, each of those customers would have to find and change all the places the attribute was used in their own code and recompile their programs.\nGoing the reverse way (from method to simple attribute) really was not a problem, as one can always just keep the function and have it simply return the attribute value.\nMeyer recognized the need for software developers to write code in such a way as to minimize or eliminate cascading changes in code that result from changes which convert an object attribute to a method call or vice versa. For this he developed the Uniform Access Principle.\nMany programming languages do not strictly support the UAP but do support forms of it.  Properties, which are provided in a number of programming languages, address the problem Meyer was addressing with his UAP in a different way. Instead of providing a single uniform notation, properties provide a way to invoke a method of an object while using the same notation as is used for attribute access.  The separate method invocation syntax is still available.\n\nUAP example\nIf the language uses the method invocation syntax it may look something like this.\n\n// Assume print displays the variable passed to it, with or without parens\n// Set Foo's attribute 'bar' to  value 5.\nFoo.bar(5)\nprint Foo.bar()\n\nWhen executed, should display :\n\n5\n\nWhether or not Foo.bar(5) invokes a function or simply sets an attribute is hidden from the caller.\nLikewise whether Foo.bar() simply retrieves the value of the attribute, or invokes a function\nto compute the value returned, is an implementation detail hidden from the caller.\nIf the language uses the attribute syntax the syntax may look like this.\n\nFoo.bar = 5\nprint Foo.bar\n\nAgain, whether or not a method is invoked, or the value is simply assigned to an attribute is hidden\nfrom the calling method.\n\nProblems\nHowever, UAP itself can lead to problems, if used in places where the differences between access methods are not negligible, such as when the returned value is expensive to compute or will trigger cache operations.\n\nLanguage examples\nPython\nPython properties may be used to allow a method\nto be invoked with the same syntax as accessing an attribute.  Whereas Meyer's UAP would have\na single notation for both attribute access and method invocation (method invocation syntax), \na language with support for properties still supports separate notations for attribute\nand method access.  Properties allow the attribute notation to be used, but to hide the\nfact that a method is being invoked instead of simply retrieving or setting a value. \nAs such, Python leaves the option of adherence to UAP up to the individual programmer. The built-in @property function provides a simple way to decorate any given method in attribute access syntax, thus abstracting away the syntactical difference between method invocations and attribute accesses.\nIn Python, we may have code that access an Egg object that could be defined such that weight and color are simple attributes as in the following \n\nOr the Egg object could use properties, and invoke getter and setter methods instead\n\nRegardless of which way Egg is defined, the calling code can remain the same.  The implementation of Egg can switch from one form to the other without affecting code that uses the Egg class. Languages which implement the UAP have this property as well.\n\nRuby\nConsider the following\n\nNow the Egg class could be defined as follows\n\nThe above initial code segment would work fine with the Egg being defined as such. The Egg\nclass could also be defined as below, where color is instead a method. The calling code would\nstill work, unchanged if Egg were to be defined as follows.\n\nNote how even though color looks like an attribute in one case and a pair of methods\nin the next, the interface to the class remains the same.  The person maintaining the Egg class can switch from one form to the other without fear of breaking any caller's code.\nRuby follows the revised UAP, the attr_accessor :color only acts as syntactic sugar for generating accessor/setter methods for color. There is no way in Ruby to retrieve an instance variable from an object without calling a method on it.\nStrictly speaking, Ruby does not follow Meyer's original UAP in that the syntax for accessing an attribute is different from the syntax for invoking a method.  But here, the access for an attribute will always actually be through a function which is often automatically generated. So in essence, either type of access invokes a function and the language does follow Meyer's revised Uniform Access Principle.\n\nC#\nThe C# language supports class properties, which provide a means to define get and set operations (getters and setters) for a member variable. The syntax to access or modify the property is the same as accessing any other class member variable, but the actual implementation for doing so can be defined as either a simple read/write access or as functional code.\n\nIn the example above, class Foo contains two properties, Size and Name. The Size property is an integer that can be read (get) and written (set). Similarly, the Name property is a string that can also be read and modified, but its value is stored in a separate (private) class variable _name.\nOmitting the set operation in a property definition makes the property read-only, while omitting the get operation makes it write-only.\nUse of the properties employs the UAP, as shown in the code below.\n\nC++\nC++ has neither the UAP nor properties, when an object is changed such that an attribute (color) becomes a pair of functions (getA, setA). Any place in that uses an instance of the object and either sets or gets the attribute value (x = obj.color or obj.color = x) must be changed to invoke one of the functions. (x = obj.getColor() or obj.setColor(x)). Using templates and operator overloading, it is possible to fake properties, but this is more complex than in languages which directly support properties. This complicates maintenance of C++ programs. Distributed libraries of C++ objects must be careful about how they provide access to member data.\n\nJavaScript\nJavaScript has had support for computed properties since 2009.\n\n\n== References ==\n",
  "categories": [
    "Category:All Wikipedia articles written in American English",
    "Category:All articles needing additional references",
    "Category:All articles with style issues",
    "Category:Articles needing additional references from January 2010",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:Programming paradigms",
    "Category:Programming principles",
    "Category:Short description matches Wikidata",
    "Category:Software design",
    "Category:Use American English from March 2019",
    "Category:Wikipedia articles with style issues from December 2024"
  ],
  "archived_date": "20241221_183043",
  "source_url": "https://en.wikipedia.org/wiki/Uniform_access_principle"
}