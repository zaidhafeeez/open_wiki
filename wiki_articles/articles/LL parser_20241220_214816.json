{
  "title": "LL parser",
  "summary": "In computer science, an LL parser (Left-to-right, leftmost derivation) is a top-down parser for a restricted context-free language. It parses the input from Left to right, performing Leftmost derivation of the sentence.\nAn LL parser is called an LL(k) parser if it uses k tokens of lookahead when parsing a sentence. A grammar is called an LL(k) grammar if an LL(k) parser can be constructed from it. A formal language is called an LL(k) language if it has an LL(k) grammar. The set of LL(k) language",
  "content": "---\ntitle: LL parser\nurl: https://en.wikipedia.org/wiki/LL_parser\nlanguage: en\ncategories: [\"Category:All Wikipedia articles needing clarification\", \"Category:All articles with unsourced statements\", \"Category:Articles with example C++ code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:Articles with unsourced statements from February 2019\", \"Category:Articles with unsourced statements from June 2022\", \"Category:CS1 maint: multiple names: authors list\", \"Category:Parsing algorithms\", \"Category:Short description is different from Wikidata\", \"Category:Wikipedia articles needing clarification from August 2021\", \"Category:Wikipedia articles needing clarification from February 2024\"]\nreferences: 0\nlast_modified: 2024-12-19T13:42:24Z\n---\n\n# LL parser\n\n## Summary\n\nIn computer science, an LL parser (Left-to-right, leftmost derivation) is a top-down parser for a restricted context-free language. It parses the input from Left to right, performing Leftmost derivation of the sentence.\nAn LL parser is called an LL(k) parser if it uses k tokens of lookahead when parsing a sentence. A grammar is called an LL(k) grammar if an LL(k) parser can be constructed from it. A formal language is called an LL(k) language if it has an LL(k) grammar. The set of LL(k) language\n\n## Full Content\n\nIn computer science, an LL parser (Left-to-right, leftmost derivation) is a top-down parser for a restricted context-free language. It parses the input from Left to right, performing Leftmost derivation of the sentence.\nAn LL parser is called an LL(k) parser if it uses k tokens of lookahead when parsing a sentence. A grammar is called an LL(k) grammar if an LL(k) parser can be constructed from it. A formal language is called an LL(k) language if it has an LL(k) grammar. The set of LL(k) languages is properly contained in that of LL(k+1) languages, for each k ≥ 0. A corollary of this is that not all context-free languages can be recognized by an LL(k) parser.\nAn LL parser is called LL-regular (LLR) if it parses an LL-regular language. The class of LLR grammars contains every LL(k) grammar for every k. For every LLR grammar there exists an LLR parser that parses the grammar in linear time.\nTwo nomenclative outlier parser types are LL(*) and LL(finite). A parser is called LL(*)/LL(finite) if it uses the LL(*)/LL(finite) parsing strategy. LL(*) and LL(finite) parsers are functionally closer to PEG parsers. An LL(finite) parser can parse an arbitrary LL(k) grammar optimally in the amount of lookahead and lookahead comparisons. The class of grammars parsable by the LL(*) strategy encompasses some context-sensitive languages due to the use of syntactic and semantic predicates and has not been identified. It has been suggested that LL(*) parsers are better thought of as TDPL parsers.\nAgainst the popular misconception, LL(*) parsers are not LLR in general, and are guaranteed by construction to perform worse on average (super-linear against linear time) and far worse in the worst-case (exponential against linear time).\nLL grammars, particularly LL(1) grammars, are of great practical interest, as parsers for these grammars are easy to construct, and many computer languages are designed to be LL(1) for this reason. LL parsers may be table-based, i.e. similar to LR parsers, but LL grammars can also be parsed by recursive descent parsers. According to Waite and Goos (1984), LL(k) grammars were introduced by Stearns and Lewis (1969).\n\nOverview\nFor a given context-free grammar, the parser attempts to find the leftmost derivation.\nGiven an example grammar \n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n:\n\n  \n    \n      \n        S\n        →\n        E\n      \n    \n    {\\displaystyle S\\to E}\n  \n\n  \n    \n      \n        E\n        →\n        (\n        E\n        +\n        E\n        )\n      \n    \n    {\\displaystyle E\\to (E+E)}\n  \n\n  \n    \n      \n        E\n        →\n        i\n      \n    \n    {\\displaystyle E\\to i}\n  \n\nthe leftmost derivation for \n  \n    \n      \n        w\n        =\n        (\n        (\n        i\n        +\n        i\n        )\n        +\n        i\n        )\n      \n    \n    {\\displaystyle w=((i+i)+i)}\n  \n is:\n\n  \n    \n      \n        S\n         \n        \n          \n            ⇒\n            \n              (\n              1\n              )\n            \n          \n        \n         \n        E\n         \n        \n          \n            ⇒\n            \n              (\n              2\n              )\n            \n          \n        \n         \n        (\n        E\n        +\n        E\n        )\n         \n        \n          \n            ⇒\n            \n              (\n              2\n              )\n            \n          \n        \n         \n        (\n        (\n        E\n        +\n        E\n        )\n        +\n        E\n        )\n         \n        \n          \n            ⇒\n            \n              (\n              3\n              )\n            \n          \n        \n         \n        (\n        (\n        i\n        +\n        E\n        )\n        +\n        E\n        )\n         \n        \n          \n            ⇒\n            \n              (\n              3\n              )\n            \n          \n        \n         \n        (\n        (\n        i\n        +\n        i\n        )\n        +\n        E\n        )\n         \n        \n          \n            ⇒\n            \n              (\n              3\n              )\n            \n          \n        \n         \n        (\n        (\n        i\n        +\n        i\n        )\n        +\n        i\n        )\n      \n    \n    {\\displaystyle S\\ {\\overset {(1)}{\\Rightarrow }}\\ E\\ {\\overset {(2)}{\\Rightarrow }}\\ (E+E)\\ {\\overset {(2)}{\\Rightarrow }}\\ ((E+E)+E)\\ {\\overset {(3)}{\\Rightarrow }}\\ ((i+E)+E)\\ {\\overset {(3)}{\\Rightarrow }}\\ ((i+i)+E)\\ {\\overset {(3)}{\\Rightarrow }}\\ ((i+i)+i)}\n  \n\nGenerally, there are multiple possibilities when selecting a rule to expand the leftmost non-terminal. In step 2 of the previous example, the parser must choose whether to apply rule 2 or rule 3:\n\n  \n    \n      \n        S\n         \n        \n          \n            ⇒\n            \n              (\n              1\n              )\n            \n          \n        \n         \n        E\n         \n        \n          \n            ⇒\n            \n              (\n              ?\n              )\n            \n          \n        \n         \n        ?\n      \n    \n    {\\displaystyle S\\ {\\overset {(1)}{\\Rightarrow }}\\ E\\ {\\overset {(?)}{\\Rightarrow }}\\ ?}\n  \n\nTo be efficient, the parser must be able to make this choice deterministically when possible, without backtracking. For some grammars, it can do this by peeking on the unread input (without reading). In our example, if the parser knows that the next unread symbol is \n  \n    \n      \n        (\n      \n    \n    {\\displaystyle (}\n  \n , the only correct rule that can be used is 2.\nGenerally, an \n  \n    \n      \n        L\n        L\n        (\n        k\n        )\n      \n    \n    {\\displaystyle LL(k)}\n  \n parser can look ahead at \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n symbols. However, given a grammar, the problem of determining if there exists a \n  \n    \n      \n        L\n        L\n        (\n        k\n        )\n      \n    \n    {\\displaystyle LL(k)}\n  \n parser for some \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n that recognizes it is undecidable. For each \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n, there is a language that cannot be recognized by an \n  \n    \n      \n        L\n        L\n        (\n        k\n        )\n      \n    \n    {\\displaystyle LL(k)}\n  \n parser, but can be by an \n  \n    \n      \n        L\n        L\n        (\n        k\n        +\n        1\n        )\n      \n    \n    {\\displaystyle LL(k+1)}\n  \n.\nWe can use the above analysis to give the following formal definition:\nLet \n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n be a context-free grammar and \n  \n    \n      \n        k\n        ≥\n        1\n      \n    \n    {\\displaystyle k\\geq 1}\n  \n. We say that \n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n is \n  \n    \n      \n        L\n        L\n        (\n        k\n        )\n      \n    \n    {\\displaystyle LL(k)}\n  \n, if and only if for any two leftmost derivations:\n\n  \n    \n      \n        S\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        A\n        α\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        β\n        α\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        u\n      \n    \n    {\\displaystyle S\\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ wA\\alpha \\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ w\\beta \\alpha \\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ wu}\n  \n\n  \n    \n      \n        S\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        A\n        α\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        γ\n        α\n         \n        ⇒\n         \n        ⋯\n         \n        ⇒\n         \n        w\n        v\n      \n    \n    {\\displaystyle S\\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ wA\\alpha \\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ w\\gamma \\alpha \\ \\Rightarrow \\ \\cdots \\ \\Rightarrow \\ wv}\n  \n\nthe following condition holds: the prefix of the string \n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n of length \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n equals the prefix of the string \n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n of length \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n implies \n  \n    \n      \n        β\n         \n        =\n         \n        γ\n      \n    \n    {\\displaystyle \\beta \\ =\\ \\gamma }\n  \n.\nIn this definition, \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n is the start symbol and \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n any non-terminal. The already derived input \n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n, and yet unread \n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n and \n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n are strings of terminals. The Greek letters \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n, \n  \n    \n      \n        β\n      \n    \n    {\\displaystyle \\beta }\n  \n and \n  \n    \n      \n        γ\n      \n    \n    {\\displaystyle \\gamma }\n  \n represent any string of both terminals and non-terminals (possibly empty). The prefix length corresponds to the lookahead buffer size, and the definition says that this buffer is enough to distinguish between any two derivations of different words.\n\nParser\nThe \n  \n    \n      \n        L\n        L\n        (\n        k\n        )\n      \n    \n    {\\displaystyle LL(k)}\n  \n parser is a deterministic pushdown automaton with the ability to peek on the next \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n input symbols without reading. This peek capability can be emulated by storing the lookahead buffer contents in the finite state space, since both buffer and input alphabet are finite in size. As a result, this does not make the automaton more powerful, but is a convenient abstraction.\nThe stack alphabet is \n  \n    \n      \n        Γ\n        =\n        N\n        ∪\n        Σ\n      \n    \n    {\\displaystyle \\Gamma =N\\cup \\Sigma }\n  \n, where:\n\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n is the set of non-terminals;\n\n  \n    \n      \n        Σ\n      \n    \n    {\\displaystyle \\Sigma }\n  \n the set of terminal (input) symbols with a special end-of-input (EOI) symbol \n  \n    \n      \n        $\n      \n    \n    {\\displaystyle \\$}\n  \n.\nThe parser stack initially contains the starting symbol above the EOI: \n  \n    \n      \n        [\n         \n        S\n         \n        $\n         \n        ]\n      \n    \n    {\\displaystyle [\\ S\\ \\$\\ ]}\n  \n. During operation, the parser repeatedly replaces the symbol \n  \n    \n      \n        X\n      \n    \n    {\\displaystyle X}\n  \n on top of the stack:\n\nwith some \n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n, if \n  \n    \n      \n        X\n        ∈\n        N\n      \n    \n    {\\displaystyle X\\in N}\n  \n and there is a rule \n  \n    \n      \n        X\n        →\n        α\n      \n    \n    {\\displaystyle X\\to \\alpha }\n  \n;\nwith \n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n (in some notations \n  \n    \n      \n        λ\n      \n    \n    {\\displaystyle \\lambda }\n  \n), i.e. \n  \n    \n      \n        X\n      \n    \n    {\\displaystyle X}\n  \n is popped off the stack, if \n  \n    \n      \n        X\n        ∈\n        Σ\n      \n    \n    {\\displaystyle X\\in \\Sigma }\n  \n. In this case, an input symbol \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n is read and if \n  \n    \n      \n        x\n        ≠\n        X\n      \n    \n    {\\displaystyle x\\neq X}\n  \n, the parser rejects the input.\nIf the last symbol to be removed from the stack is the EOI, the parsing is successful; the automaton accepts via an empty stack.\nThe states and the transition function are not explicitly given; they are specified (generated) using a more convenient parse table instead. The table provides the following mapping:\n\nrow: top-of-stack symbol \n  \n    \n      \n        X\n      \n    \n    {\\displaystyle X}\n  \n\ncolumn: \n  \n    \n      \n        \n          |\n        \n        w\n        \n          |\n        \n        ≤\n        k\n      \n    \n    {\\displaystyle |w|\\leq k}\n  \n lookahead buffer contents\ncell: rule number for \n  \n    \n      \n        X\n        →\n        α\n      \n    \n    {\\displaystyle X\\to \\alpha }\n  \n or \n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n\nIf the parser cannot perform a valid transition, the input is rejected (empty cells). To make the table more compact, only the non-terminal rows are commonly displayed, since the action is the same for terminals.\n\nConcrete example\nSet up\nTo explain an LL(1) parser's workings we will consider the following small LL(1) grammar:\n\nS → F\nS → ( S + F )\nF → a\nand parse the following input:\n\n( a + a )\nAn LL(1) parsing table for a grammar has a row for each of the non-terminals and a column for each terminal (including the special terminal, represented here as $, that is used to indicate the end of the input stream).\nEach cell of the table may point to at most one rule of the grammar (identified by its number). For example, in the parsing table for the above grammar, the cell for the non-terminal 'S' and terminal '(' points to the rule number 2:\n\nThe algorithm to construct a parsing table is described in a later section, but first let's see how the parser uses the parsing table to process its input.\n\nParsing procedure\nIn each step, the parser reads the next-available symbol from the input stream, and the top-most symbol from the stack. If the input symbol and the stack-top symbol match, the parser discards them both, leaving only the unmatched symbols in the input stream and on the stack.\nThus, in its first step, the parser reads the input symbol '(' and the stack-top symbol 'S'. The parsing table instruction comes from the column headed by the input symbol '(' and the row headed by the stack-top symbol 'S'; this cell contains '2', which instructs the parser to apply rule (2).  The parser has to rewrite 'S' to '( S + F )' on the stack by removing 'S' from stack and pushing ')', 'F', '+', 'S', '(' onto the stack, and this writes the rule number 2 to the output. The stack then becomes:\n\n[ (, S, +, F, ), $ ]\n\nIn the second step, the parser removes the '(' from its input stream and from its stack, since they now match. The stack now becomes:\n\n[ S, +, F, ), $ ]\n\nNow the parser has an 'a' on its input stream and an 'S' as its stack top. The parsing table instructs it to apply rule (1) from the grammar and write the rule number 1 to the output stream. The stack becomes:\n\n[ F, +, F, ), $ ]\n\nThe parser now has an 'a' on its input stream and an 'F' as its stack top. The parsing table instructs it to apply rule (3) from the grammar and write the rule number 3 to the output stream. The stack becomes:\n\n[ a, +, F, ), $ ]\n\nThe parser now has an 'a' on the input stream and an 'a' at its stack top. Because they are the same, it removes it from the input stream and pops it from the top of the stack. The parser then has an '+' on the input stream and '+' is at the top of the stack meaning, like with 'a', it is popped from the stack and removed from the input stream. This results in:\n\n[ F, ), $ ]\n\nIn the next three steps the parser will replace 'F' on the stack by 'a', write the rule number 3 to the output stream and remove the 'a' and ')' from both the stack and the input stream. The parser thus ends with '$' on both its stack and its input stream.\nIn this case the parser will report that it has accepted the input string and write the following list of rule numbers to the output stream:\n\n[ 2, 1, 3, 3 ]\nThis is indeed a list of rules for a leftmost derivation of the input string, which is:\n\nS → ( S + F ) → ( F + F ) → ( a + F ) → ( a + a )\n\nParser implementation in C++\nBelow follows a C++ implementation of a table-based LL parser for the example language:\n\nParser implementation in Python\nRemarks\nAs can be seen from the example, the parser performs three types of steps depending on whether the top of the stack is a nonterminal, a terminal or the special symbol $:\n\nIf the top is a nonterminal then the parser looks up in the parsing table, on the basis of this nonterminal and the symbol on the input stream, which rule of the grammar it should use to replace nonterminal on the stack. The number of the rule is written to the output stream. If the parsing table indicates that there is no such rule then the parser reports an error and stops.\nIf the top is a terminal then the parser compares it to the symbol on the input stream and if they are equal they are both removed. If they are not equal the parser reports an error and stops.\nIf the top is $ and on the input stream there is also a $ then the parser reports that it has successfully parsed the input, otherwise it reports an error. In both cases the parser will stop.\nThese steps are repeated until the parser stops, and then it will have either completely parsed the input and written a leftmost derivation to the output stream or it will have reported an error.\n\nConstructing an LL(1) parsing table\nIn order to fill the parsing table, we have to establish what grammar rule the parser should choose if it sees a nonterminal A on the top of its stack and a symbol a on its input stream.\nIt is easy to see that such a rule should be of the form A → w and that the language corresponding to w should have at least one string starting with a.\nFor this purpose we define the First-set of w, written here as Fi(w), as the set of terminals that can be found at the start of some string in w, plus ε if the empty string also belongs to w.\nGiven a grammar with the rules A1 → w1, …, An → wn, we can compute the Fi(wi) and Fi(Ai) for every rule as follows:\n\ninitialize every Fi(Ai) with the empty set\nadd Fi(wi) to Fi(Ai) for every rule Ai → wi, where Fi is defined as follows:\nFi(aw') = { a } for every terminal a\nFi(Aw') = Fi(A) for every nonterminal A with ε not in Fi(A)\nFi(Aw' ) = (Fi(A) \\ { ε }) ∪ Fi(w' ) for every nonterminal A with ε in Fi(A)\nFi(ε) = { ε }\nadd Fi(wi) to Fi(Ai) for every rule Ai → wi\ndo steps 2 and 3 until all Fi sets stay the same.\nThe result is the least fixed point solution to the following system:\n\nFi(A) ⊇ Fi(w) for each rule A → w\nFi(a) ⊇ { a }, for each terminal a\nFi(w0 w1) ⊇ Fi(w0)·Fi(w1), for all words w0 and w1\nFi(ε) ⊇ {ε}\nwhere, for sets of words U and V, the truncated product is defined by \n  \n    \n      \n        U\n        ⋅\n        V\n        =\n        {\n        (\n        u\n        v\n        )\n        :\n        1\n        ∣\n        u\n        ∈\n        U\n        ,\n        v\n        ∈\n        V\n        }\n      \n    \n    {\\displaystyle U\\cdot V=\\{(uv):1\\mid u\\in U,v\\in V\\}}\n  \n, and w:1 denotes the initial length-1 prefix of words w of length 2 or more, or w, itself, if w has length 0 or 1.\nUnfortunately, the First-sets are not sufficient to compute the parsing table.\nThis is because a right-hand side w of a rule might ultimately be rewritten to the empty string.\nSo the parser should also use the rule A → w if ε is in Fi(w) and it sees on the input stream a symbol that could follow A. Therefore, we also need the Follow-set of A, written as Fo(A) here, which is defined as the set of terminals a such that there is a string of symbols αAaβ that can be derived from the start symbol. We use $ as a special terminal indicating end of input stream, and S as start symbol.\nComputing the Follow-sets for the nonterminals in a grammar can be done as follows:\n\ninitialize Fo(S) with { $ } and every other Fo(Ai) with the empty set\nif there is a rule of the form Aj → wAiw' , then\nif the terminal a is in Fi(w' ), then add a to Fo(Ai)\nif ε is in Fi(w' ), then add Fo(Aj) to Fo(Ai)\nif w'  has length 0, then add Fo(Aj) to Fo(Ai)\nrepeat step 2 until all Fo sets stay the same.\nThis provides the least fixed point solution to the following system:\n\nFo(S) ⊇ {$}\nFo(A) ⊇ Fi(w)·Fo(B) for each rule of the form B → ... A w\nNow we can define exactly which rules will appear where in the parsing table.\nIf T[A, a] denotes the entry in the table for nonterminal A and terminal a, then\n\nT[A,a] contains the rule A → w if and only if\na is in Fi(w) or\nε is in Fi(w) and a is in Fo(A).\nEquivalently: T[A, a] contains the rule A → w for each a ∈ Fi(w)·Fo(A).\nIf the table contains at most one rule in every one of its cells, then the parser will always know which rule it has to use and can therefore parse strings without backtracking.\nIt is in precisely this case that the grammar is called an LL(1) grammar.\n\nConstructing an LL(k) parsing table\nThe construction for LL(1) parsers can be adapted to LL(k) for k > 1 with the following modifications:\n\nthe truncated product is defined \n  \n    \n      \n        U\n        ⋅\n        V\n        =\n        {\n        (\n        u\n        v\n        )\n        :\n        k\n        ∣\n        u\n        ∈\n        U\n        ,\n        v\n        ∈\n        V\n        }\n      \n    \n    {\\displaystyle U\\cdot V=\\{(uv):k\\mid u\\in U,v\\in V\\}}\n  \n, where w:k denotes the initial length-k prefix of words of length > k, or w, itself, if w has length k or less,\nFo(S) = {$k}\nApply Fi(αβ) = Fi(α)\n  \n    \n      \n        ⋅\n      \n    \n    {\\displaystyle \\cdot }\n  \nFi(β) also in step 2 of the Fi construction given for LL(1).\nIn step 2 of the Fo construction, for Aj → wAiw' simply add Fi(w')\n  \n    \n      \n        ⋅\n      \n    \n    {\\displaystyle \\cdot }\n  \nFo(Aj) to Fo(Ai).\nwhere an input is suffixed by k end-markers $, to fully account for the k lookahead context.  This approach eliminates special cases for ε, and can be applied equally well in the LL(1) case.\nUntil the mid-1990s, it was widely believed that LL(k) parsing (for k > 1) was impractical,: 263–265  since the parser table would have exponential size in k in the worst case. This perception changed gradually after the release of the Purdue Compiler Construction Tool Set around 1992, when it was demonstrated that many programming languages can be parsed efficiently by an LL(k) parser without triggering the worst-case behavior of the parser.  Moreover, in certain cases LL parsing is feasible even with unlimited lookahead.  By contrast, traditional parser generators like yacc use LALR(1) parser tables to construct a restricted LR parser with a fixed one-token lookahead.\n\nConflicts\nAs described in the introduction, LL(1) parsers recognize languages that have LL(1) grammars, which are a special case of context-free grammars; LL(1) parsers cannot recognize all context-free languages. The LL(1) languages are a proper subset of the LR(1) languages, which in turn are a proper subset of all context-free languages.  In order for a context-free grammar to be an LL(1) grammar, certain conflicts must not arise, which we describe in this section.\n\nTerminology\nLet A be a non-terminal. FIRST(A) is (defined to be) the set of terminals that can appear in the first position of any string derived from A. FOLLOW(A) is the union over:\n\nFIRST(B) where B is any non-terminal that immediately follows A in the right-hand side of a production rule.\nFOLLOW(B) where B is any head of a rule of the form B → wA.\n\nLL(1) conflicts\nThere are two main types of LL(1) conflicts:\n\nFIRST/FIRST conflict\nThe FIRST sets of two different grammar rules for the same non-terminal intersect.\nAn example of an LL(1) FIRST/FIRST conflict:\n\nS -> E | E 'a'\nE -> 'b' | ε\n\nFIRST(E) = {b, ε} and FIRST(E a) = {b, a}, so when the table is drawn, there is conflict under terminal b of production rule S.\n\nSpecial case: left recursion\nLeft recursion will cause a FIRST/FIRST conflict with all alternatives.\n\nE -> E '+' term | alt1 | alt2\n\nFIRST/FOLLOW conflict\nThe FIRST and FOLLOW set of a grammar rule overlap. With an empty string (ε) in the FIRST set, it is unknown which alternative to select.\nAn example of an LL(1) conflict:\n\nS -> A 'a' 'b'\nA -> 'a' | ε\n\nThe FIRST set of A is {a, ε}, and the FOLLOW set is {a}.\n\nSolutions to LL(1) conflicts\nLeft factoring\nA common left-factor is \"factored out\".\n\nA -> X | X Y Z\n\nbecomes\n\nA -> X B\nB -> Y Z | ε\n\nCan be applied when two alternatives start with the same symbol like a FIRST/FIRST conflict.\nAnother example (more complex) using above FIRST/FIRST conflict example:\n\nS -> E | E 'a'\nE -> 'b' | ε\n\nbecomes (merging into a single non-terminal)\n\nS -> 'b' | ε | 'b' 'a' | 'a'\n\nthen through left-factoring, becomes\n\nS -> 'b' E | E\nE -> 'a' | ε\n\nSubstitution\nSubstituting a rule into another rule to remove indirect or FIRST/FOLLOW conflicts.\nNote that this may cause a FIRST/FIRST conflict.\n\nLeft recursion removal\nSee.\nFor a general method, see removing left recursion.\nA simple example for left recursion removal:\nThe following production rule has left recursion on E\n\nE -> E '+' T\nE -> T\n\nThis rule is nothing but list of Ts separated by '+'. In a regular expression form T ('+' T)*.\nSo the rule could be rewritten as \n\nE -> T Z\nZ -> '+' T Z\nZ -> ε\n\nNow there is no left recursion and no conflicts on either of the rules.\nHowever, not all context-free grammars have an equivalent LL(k)-grammar, e.g.:\n\nS -> A | B\nA -> 'a' A 'b' | ε\nB -> 'a' B 'b' 'b' | ε\n\nIt can be shown that there does not exist any LL(k)-grammar accepting the language generated by this grammar.\n\nSee also\nComparison of parser generators\nParse tree\nTop-down parsing\nBottom-up parsing\n\nNotes\nExternal links\nA tutorial on implementing LL(1) parsers in C# (archived)\nParsing Simulator This simulator is used to generate parsing tables LL(1) and to resolve the exercises of the book.\nLanguage theoretic comparison of LL and LR grammars\nLL(k) Parsing Theory\n",
  "categories": [
    "Category:All Wikipedia articles needing clarification",
    "Category:All articles with unsourced statements",
    "Category:Articles with example C++ code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:Articles with unsourced statements from February 2019",
    "Category:Articles with unsourced statements from June 2022",
    "Category:CS1 maint: multiple names: authors list",
    "Category:Parsing algorithms",
    "Category:Short description is different from Wikidata",
    "Category:Wikipedia articles needing clarification from August 2021",
    "Category:Wikipedia articles needing clarification from February 2024"
  ],
  "archived_date": "20241220_214816",
  "source_url": "https://en.wikipedia.org/wiki/LL_parser"
}