{
  "title": "Ruzzo–Tompa algorithm",
  "summary": "The Ruzzo–Tompa algorithm or the RT algorithm is a linear-time algorithm for finding all non-overlapping, contiguous, maximal scoring subsequences in a sequence of real numbers. The Ruzzo–Tompa algorithm was proposed by Walter L. Ruzzo and Martin Tompa. This algorithm is an improvement over previously known quadratic time algorithms. The maximum scoring subsequence from the set produced by the algorithm is also a solution to the maximum subarray problem.\nThe Ruzzo–Tompa algorithm has application",
  "content": "---\ntitle: Ruzzo–Tompa algorithm\nurl: https://en.wikipedia.org/wiki/Ruzzo%E2%80%93Tompa_algorithm\nlanguage: en\ncategories: [\"Category:Articles with example Python (programming language) code\", \"Category:Dynamic programming\", \"Category:Optimization algorithms and methods\"]\nreferences: 0\nlast_modified: 2024-11-07T05:10:46Z\n---\n\n# Ruzzo–Tompa algorithm\n\n## Summary\n\nThe Ruzzo–Tompa algorithm or the RT algorithm is a linear-time algorithm for finding all non-overlapping, contiguous, maximal scoring subsequences in a sequence of real numbers. The Ruzzo–Tompa algorithm was proposed by Walter L. Ruzzo and Martin Tompa. This algorithm is an improvement over previously known quadratic time algorithms. The maximum scoring subsequence from the set produced by the algorithm is also a solution to the maximum subarray problem.\nThe Ruzzo–Tompa algorithm has application\n\n## Full Content\n\nThe Ruzzo–Tompa algorithm or the RT algorithm is a linear-time algorithm for finding all non-overlapping, contiguous, maximal scoring subsequences in a sequence of real numbers. The Ruzzo–Tompa algorithm was proposed by Walter L. Ruzzo and Martin Tompa. This algorithm is an improvement over previously known quadratic time algorithms. The maximum scoring subsequence from the set produced by the algorithm is also a solution to the maximum subarray problem.\nThe Ruzzo–Tompa algorithm has applications in bioinformatics, web scraping, and information retrieval.\n\nApplications\nBioinformatics\nThe Ruzzo–Tompa algorithm has been used in Bioinformatics tools to study biological data. The problem of finding disjoint maximal subsequences is of practical importance in the analysis of DNA. Maximal subsequences algorithms have been used in the identification of transmembrane segments and the evaluation of sequence homology.\nThe algorithm is used in sequence alignment which is used as a method of identifying similar DNA, RNA, or protein sequences. Accounting for the ordering of pairs of high-scoring subsequences in two sequences creates better sequence alignments. This is because the biological model suggests that separate high-scoring subsequence pairs arise from insertions or deletions within a matching region. Requiring consistent ordering of high-scoring subsequence pairs increases their statistical significance.\n\nWeb scraping\nThe Ruzzo–Tompa algorithm is used in Web scraping to extract information from web pages. Pasternack and Roth proposed a method for extracting important blocks of text from HTML documents. The web pages are first tokenized and the score for each token is found using local, token-level classifiers. A modified version of the Ruzzo–Tompa algorithm is then used to find the k highest-valued subsequences of tokens. These subsequences are then used as predictions of important blocks of text in the article.\n\nInformation retrieval\nThe Ruzzo–Tompa algorithm has been used in Information retrieval search algorithms. Liang et al. proposed a data fusion method to combine the search results of several microblog search algorithms. In their method, the Ruzzo–Tompa algorithm is used to detect bursts of information.\n\nProblem definition\nThe problem of finding all maximal subsequences is defined as follows: Given a list of real numbered scores \n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          x\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{1},x_{2},\\ldots ,x_{n}}\n  \n, find the list of contiguous subsequences that gives the greatest total score, where the score of each subsequence \n  \n    \n      \n        \n          S\n          \n            i\n            ,\n            j\n          \n        \n        =\n        \n          ∑\n          \n            i\n            ≤\n            k\n            ≤\n            j\n          \n        \n        \n          x\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{i,j}=\\sum _{i\\leq k\\leq j}x_{k}}\n  \n. The subsequences must be disjoint (non-overlapping) and have a positive score.\n\nOther algorithms\nThere are several approaches to solving the all maximal scoring subsequences problem. A natural approach is to use existing, linear time algorithms to find the maximum subsequence (see maximum subarray problem) and then recursively find the maximal subsequences to the left and right of the maximum subsequence. The analysis of this algorithm is similar to that of Quicksort: The maximum subsequence could be small in comparison to the rest of sequence, leading to a running time of \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n in the worst case.\n\nAlgorithm\nThe standard implementation of the Ruzzo–Tompa algorithm runs in \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n time and uses O(n) space, where n is the length of the list of scores. The algorithm uses dynamic programming to progressively build the final solution by incrementally solving progressively larger subsets of the problem. The description of the algorithm provided by Ruzzo and Tompa is as follows:\n\nRead the scores left to right and maintain the cumulative sum of the scores read. Maintain an ordered list \n  \n    \n      \n        \n          I\n          \n            1\n          \n        \n        ,\n        \n          I\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{1},I_{2},\\ldots ,I_{j}}\n  \n of disjoint subsequences. For each subsequence \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{j}}\n  \n, record the cumulative total \n  \n    \n      \n        \n          L\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle L_{j}}\n  \n of all scores up to but not including the leftmost score of \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{j}}\n  \n, and the total \n  \n    \n      \n        \n          R\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle R_{j}}\n  \n up to and including the rightmost score of \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{j}}\n  \n.\nThe lists are initially empty. Scores are read from left to right and are processed as follows. Nonpositive scores require no special processing, so the next score is read. A positive score is incorporated into a new sub-sequence \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n of length one that is then integrated into the list by the following process:\nThe list \n  \n    \n      \n        I\n      \n    \n    {\\displaystyle I}\n  \n is searched from right to left for the maximum value of \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n satisfying \n  \n    \n      \n        \n          L\n          \n            j\n          \n        \n        <\n        \n          L\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle L_{j}<L_{k}}\n  \n\nIf there is no such \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n, then add \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n to the end of the list.\nIf there is such a \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n, and \n  \n    \n      \n        \n          R\n          \n            j\n          \n        \n        ≥\n        \n          R\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle R_{j}\\geq R_{k}}\n  \n, then add \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n to the end of the list.\nOtherwise (i.e., there is such a j, but \n  \n    \n      \n        \n          R\n          \n            j\n          \n        \n        <\n        \n          R\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle R_{j}<R_{k}}\n  \n), extend the subsequence \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n to the left to encompass everything up to and including the leftmost score in \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{j}}\n  \n. Delete subsequences \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n        ,\n        \n          I\n          \n            j\n          \n        \n        +\n        1\n        ,\n        …\n        ,\n        \n          I\n          \n            k\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle I_{j},I_{j}+1,\\ldots ,I_{k}-1}\n  \n from the list, and append \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n to the end of the list. Reconsider the newly extended subsequence \n  \n    \n      \n        \n          I\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle I_{k}}\n  \n (now renumbered \n  \n    \n      \n        \n          I\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle I_{j}}\n  \n) as in step 1.\nOnce the end of the input is reached, all subsequences remaining on the list \n  \n    \n      \n        I\n      \n    \n    {\\displaystyle I}\n  \n are maximal.\nThe following Python code implements the Ruzzo–Tompa algorithm:\n\nSee also\nMaximum subarray problem\nQuicksort\n\nReferences\nFurther reading\nAli, Syed Arslan; Raza, Basit; Malik, Ahmad Kamran; Shahid, Ahmad Raza; Faheem, Muhammad; Alquhayz, Hani; Kumar, Yogan Jaya (2020). \"An Optimally Configured and Improved Deep Belief Network (OCI-DBN) Approach for Heart Disease Prediction Based on Ruzzo–Tompa and Stacked Genetic Algorithm\". IEEE Access. 8. Institute of Electrical and Electronics Engineers (IEEE): 65947–65958. doi:10.1109/access.2020.2985646. ISSN 2169-3536. S2CID 215817246.\n",
  "categories": [
    "Category:Articles with example Python (programming language) code",
    "Category:Dynamic programming",
    "Category:Optimization algorithms and methods"
  ],
  "archived_date": "20241221_183043",
  "source_url": "https://en.wikipedia.org/wiki/Ruzzo%E2%80%93Tompa_algorithm"
}