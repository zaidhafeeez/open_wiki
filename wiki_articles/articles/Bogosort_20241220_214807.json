{
  "title": "Bogosort",
  "summary": "In computer science, bogosort (also known as permutation sort and stupid sort) is a sorting algorithm based on the generate and test paradigm. The function successively generates permutations of its input until it finds one that is sorted. It is not considered useful for sorting, but may be used for educational purposes, to contrast it with more efficient algorithms. The algorithm's name is a portmanteau of the words bogus and sort.\nTwo versions of this algorithm exist: a deterministic version t",
  "content": "---\ntitle: Bogosort\nurl: https://en.wikipedia.org/wiki/Bogosort\nlanguage: en\ncategories: [\"Category:All articles with dead external links\", \"Category:Articles with dead external links from July 2020\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with permanently dead external links\", \"Category:Articles with short description\", \"Category:Comparison sorts\", \"Category:Short description is different from Wikidata\", \"Category:Use dmy dates from December 2021\"]\nreferences: 0\nlast_modified: 2024-12-19T13:42:37Z\n---\n\n# Bogosort\n\n## Summary\n\nIn computer science, bogosort (also known as permutation sort and stupid sort) is a sorting algorithm based on the generate and test paradigm. The function successively generates permutations of its input until it finds one that is sorted. It is not considered useful for sorting, but may be used for educational purposes, to contrast it with more efficient algorithms. The algorithm's name is a portmanteau of the words bogus and sort.\nTwo versions of this algorithm exist: a deterministic version t\n\n## Full Content\n\nIn computer science, bogosort (also known as permutation sort and stupid sort) is a sorting algorithm based on the generate and test paradigm. The function successively generates permutations of its input until it finds one that is sorted. It is not considered useful for sorting, but may be used for educational purposes, to contrast it with more efficient algorithms. The algorithm's name is a portmanteau of the words bogus and sort.\nTwo versions of this algorithm exist: a deterministic version that enumerates all permutations until it hits a sorted one, and a randomized version that randomly permutes its input and checks whether it is sorted. An analogy for the working of the latter version is to sort a deck of cards by throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. In a worst-case scenario with this version, the random source is of low quality and happens to make the sorted permutation unlikely to occur.\n\nDescription of the algorithm\nPseudocode\nThe following is a description of the randomized algorithm in pseudocode:\n\nwhile deck is not sorted:\n    shuffle(deck)\n\nC\nAn implementation in C:\n\nPython\nAn implementation in Python 3:\n\nThis code assumes that data is a simple, mutable, array-like data structure—like Python's built-in list—whose elements can be compared without issue.\n\nRunning time and termination\nIf all elements to be sorted are distinct, the expected number of comparisons performed in the average case by randomized bogosort is asymptotically equivalent to (e − 1)n!, and the expected number of swaps in the average case equals (n − 1)n!. The expected number of swaps grows faster than the expected number of comparisons, because if the elements are not in order, this will usually be discovered after only a few comparisons, no matter how many elements there are; but the work of shuffling the collection is proportional to its size. In the worst case, the number of comparisons and swaps are both unbounded, for the same reason that a tossed coin might turn up heads any number of times in a row.\nThe best case occurs if the list as given is already sorted; in this case the expected number of comparisons is n − 1, and no swaps at all are carried out.\nFor any collection of fixed size, the expected running time of the algorithm is finite for much the same reason that the infinite monkey theorem holds: there is some probability of getting the right permutation, so given an unbounded number of tries it will almost surely eventually be chosen.\n\nRelated algorithms\nGorosort\nA sorting algorithm introduced in the 2011 Google Code Jam. As long as the list is not in order, a subset of all elements is randomly permuted. If this subset is optimally chosen each time this is performed, the expected value of the total number of times this operation needs to be done is equal to the number of misplaced elements.\n\nBogobogosort\nAn algorithm that recursively calls itself with smaller and smaller copies of the beginning of the list to see if they are sorted.  The base case is a single element, which is always sorted. For other cases, it compares the last element to the maximum element from the previous elements in the list.  If the last element is greater or equal, it checks if the order of the copy matches the previous version, and if so returns. Otherwise, it reshuffles the current copy of the list and restarts its recursive check.\n\nBozosort\nAnother sorting algorithm based on random numbers. If the list is not in order, it picks two items at random and swaps them, then checks to see if the list is sorted. The running time analysis of a bozosort is more difficult, but some estimates are found in H. Gruber's analysis of \"perversely awful\" randomized sorting algorithms. O(n!) is found to be the expected average case.\n\nWorstsort\nA pessimal sorting algorithm that is guaranteed to complete in finite time; however, its efficiency can be arbitrarily bad, depending on its configuration. The worstsort algorithm is based on a bad sorting algorithm, badsort. The badsort algorithm accepts two parameters: L, which is the list to be sorted, and k, which is a recursion depth. At recursion level k = 0, badsort merely uses a common sorting algorithm, such as bubblesort, to sort its inputs and return the sorted list. That is to say, badsort(L, 0) = bubblesort(L). Therefore, badsort's time complexity is O(n2) if k = 0. However, for any k > 0, badsort(L, k) first generates P, the list of all permutations of L. Then, badsort calculates badsort(P, k − 1), and returns the first element of the sorted P. To make worstsort truly pessimal, k may be assigned to the value of a computable increasing function such as \n  \n    \n      \n        f\n        :\n        \n          N\n        \n        →\n        \n          N\n        \n      \n    \n    {\\displaystyle f\\colon \\mathbb {N} \\to \\mathbb {N} }\n  \n (e.g. f(n) = A(n, n), where A is Ackermann's function).  Therefore, to sort a list arbitrarily badly, one would execute worstsort(L, f) = badsort(L, f(length(L))), where length(L) is the number of elements in L. The resulting algorithm has complexity \n  \n    \n      \n        Ω\n        \n          (\n          \n            \n              (\n              \n                n\n                \n                  !\n                  \n                    (\n                    f\n                    (\n                    n\n                    )\n                    )\n                  \n                \n              \n              )\n            \n            \n              2\n            \n          \n          )\n        \n      \n    \n    {\\textstyle \\Omega \\left(\\left(n!^{(f(n))}\\right)^{2}\\right)}\n  \n, where \n  \n    \n      \n        n\n        \n          !\n          \n            (\n            m\n            )\n          \n        \n        =\n        (\n        …\n        (\n        (\n        n\n        !\n        )\n        !\n        )\n        !\n        …\n        )\n        !\n      \n    \n    {\\displaystyle n!^{(m)}=(\\dotso ((n!)!)!\\dotso )!}\n  \n = factorial of n iterated m times. This algorithm can be made as inefficient as one wishes by picking a fast enough growing function f.\nSlowsort\nA different humorous sorting algorithm that employs a misguided divide-and-conquer strategy to achieve massive complexity.\nQuantum bogosort\nA hypothetical sorting algorithm based on bogosort, created as an in-joke among computer scientists. The algorithm generates a random permutation of its input using a quantum source of entropy, checks if the list is sorted, and, if it is not, destroys the universe. Assuming that the many-worlds interpretation holds, the use of this algorithm will result in at least one surviving universe where the input was successfully sorted in O(n) time.\nMiracle sort\nA sorting algorithm that checks if the array is sorted until a miracle occurs. It continually checks the array until it is sorted, never changing the order of the array. Because the order is never altered, the algorithm has a hypothetical time complexity of O(∞), but it can still sort through events such as miracles or single-event upsets. Particular care must be taken in the implementation of this algorithm as optimizing compilers may simply transform it into a while(true) loop. However, the best case is O(n), which happens on a sorted list. Since it only makes comparisons, it is both strictly in-place and stable.\nBozobogo sort\nA sorting algorithm that only works if the list is already in order, otherwise, the conditions of miracle sort are applied.\nDivine sort\nA sorting algorithm that takes a list and decides that because there is such a low probability that the list randomly  occurred in its current permutation (a probability of 1/n!, where n is the number of elements), there must have been a reason for the list's order. Therefore, it should be considered sorted in a way we don't understand, and we do not have any right to sort it to our beliefs, as if it were sorted \"as God intended.\" Also known as Intelligent Design sort.\n\nSee also\nLas Vegas algorithm\nStooge sort\n\nReferences\nExternal links\n\nBogoSort on WikiWikiWeb\nInefficient sort algorithms\nBogosort: an implementation that runs on Unix-like systems, similar to the standard sort program.\nBogosort and jmmcg::bogosort: Simple, yet perverse, C++ implementations of the bogosort algorithm.\nBogosort NPM package: bogosort implementation for Node.js ecosystem.\nMax Sherman Bogo-sort is Sort of Slow, June 2013\n",
  "categories": [
    "Category:All articles with dead external links",
    "Category:Articles with dead external links from July 2020",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with permanently dead external links",
    "Category:Articles with short description",
    "Category:Comparison sorts",
    "Category:Short description is different from Wikidata",
    "Category:Use dmy dates from December 2021"
  ],
  "archived_date": "20241220_214807",
  "source_url": "https://en.wikipedia.org/wiki/Bogosort"
}