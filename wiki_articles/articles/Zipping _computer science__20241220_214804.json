{
  "title": "Zipping (computer science)",
  "summary": "In computer science, zipping is a function which maps a tuple of sequences into a sequence of tuples.  This name zip derives from the action of a zipper in that it interleaves two formerly disjoint sequences.  The inverse function is unzip.",
  "content": "---\ntitle: Zipping (computer science)\nurl: https://en.wikipedia.org/wiki/Zipping_(computer_science)\nlanguage: en\ncategories: [\"Category:Articles with example Clojure code\", \"Category:Articles with example Haskell code\", \"Category:Articles with example Lisp (programming language) code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:Data mapping\", \"Category:Short description is different from Wikidata\"]\nreferences: 0\nlast_modified: 2024-12-19T13:47:31Z\n---\n\n# Zipping (computer science)\n\n## Summary\n\nIn computer science, zipping is a function which maps a tuple of sequences into a sequence of tuples.  This name zip derives from the action of a zipper in that it interleaves two formerly disjoint sequences.  The inverse function is unzip.\n\n## Full Content\n\nIn computer science, zipping is a function which maps a tuple of sequences into a sequence of tuples.  This name zip derives from the action of a zipper in that it interleaves two formerly disjoint sequences.  The inverse function is unzip.\n\nExample\nGiven the three words cat, fish and be where |cat| is 3, |fish| is 4 and |be| is 2. Let \n  \n    \n      \n        ℓ\n      \n    \n    {\\displaystyle \\ell }\n  \n denote the length of the longest word which is fish; \n  \n    \n      \n        ℓ\n        =\n        4\n      \n    \n    {\\displaystyle \\ell =4}\n  \n. The zip of cat, fish, be is then 4 tuples of elements:\n\n  \n    \n      \n        (\n        c\n        ,\n        f\n        ,\n        b\n        )\n        (\n        a\n        ,\n        i\n        ,\n        e\n        )\n        (\n        t\n        ,\n        s\n        ,\n        #\n        )\n        (\n        #\n        ,\n        h\n        ,\n        #\n        )\n      \n    \n    {\\displaystyle (c,f,b)(a,i,e)(t,s,\\#)(\\#,h,\\#)}\n  \n\nwhere # is a symbol not in the original alphabet. In Haskell this truncates to the shortest sequence \n  \n    \n      \n        \n          \n            ℓ\n            _\n          \n        \n      \n    \n    {\\displaystyle {\\underline {\\ell }}}\n  \n, where \n  \n    \n      \n        \n          \n            ℓ\n            _\n          \n        \n        =\n        2\n      \n    \n    {\\displaystyle {\\underline {\\ell }}=2}\n  \n:\n\nDefinition\nLet Σ be an alphabet, # a symbol not in Σ.\nLet x1x2... x|x|, y1y2... y|y|, z1z2... z|z|, ... be n words (i.e. finite sequences) of elements of Σ. Let \n  \n    \n      \n        ℓ\n      \n    \n    {\\displaystyle \\ell }\n  \n denote the length of the longest word, i.e. the maximum of |x|, |y|, |z|, ... .\nThe zip of these words is a finite sequence of n-tuples of elements of (Σ ∪ {#}), i.e. an element of \n  \n    \n      \n        (\n        (\n        Σ\n        ∪\n        {\n        #\n        }\n        \n          )\n          \n            n\n          \n        \n        \n          )\n          \n            ∗\n          \n        \n      \n    \n    {\\displaystyle ((\\Sigma \\cup \\{\\#\\})^{n})^{*}}\n  \n:\n\n  \n    \n      \n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          y\n          \n            1\n          \n        \n        ,\n        …\n        )\n        (\n        \n          x\n          \n            2\n          \n        \n        ,\n        \n          y\n          \n            2\n          \n        \n        ,\n        …\n        )\n        …\n        (\n        \n          x\n          \n            ℓ\n          \n        \n        ,\n        \n          y\n          \n            ℓ\n          \n        \n        ,\n        …\n        )\n      \n    \n    {\\displaystyle (x_{1},y_{1},\\ldots )(x_{2},y_{2},\\ldots )\\ldots (x_{\\ell },y_{\\ell },\\ldots )}\n  \n,\nwhere for any index i > |w|, the wi is #.\nThe zip of x, y, z, ... is denoted zip(x, y, z, ...) or x ⋆ y ⋆ z ⋆ ...\nThe inverse to zip is sometimes denoted unzip.\nA variation of the zip operation is defined by:\n\n  \n    \n      \n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          y\n          \n            1\n          \n        \n        ,\n        …\n        )\n        (\n        \n          x\n          \n            2\n          \n        \n        ,\n        \n          y\n          \n            2\n          \n        \n        ,\n        …\n        )\n        …\n        (\n        \n          x\n          \n            \n              ℓ\n              _\n            \n          \n        \n        ,\n        \n          y\n          \n            \n              ℓ\n              _\n            \n          \n        \n        ,\n        …\n        )\n      \n    \n    {\\displaystyle (x_{1},y_{1},\\ldots )(x_{2},y_{2},\\ldots )\\ldots (x_{\\underline {\\ell }},y_{\\underline {\\ell }},\\ldots )}\n  \n\nwhere \n  \n    \n      \n        \n          \n            ℓ\n            _\n          \n        \n      \n    \n    {\\displaystyle {\\underline {\\ell }}}\n  \n is the minimum length of the input words.  It avoids the use of an adjoined element \n  \n    \n      \n        #\n      \n    \n    {\\displaystyle \\#}\n  \n, but destroys information about elements of the input sequences beyond \n  \n    \n      \n        \n          \n            ℓ\n            _\n          \n        \n      \n    \n    {\\displaystyle {\\underline {\\ell }}}\n  \n.\n\nIn programming languages\nZip functions are often available in programming languages, often referred to as zip. In Lisp-dialects one can simply map the desired function over the desired lists, map is variadic in Lisp so it can take an arbitrary number of lists as argument. An example from Clojure:\n\nIn Common Lisp:\n\nLanguages such as Python provide a zip() function. zip() in conjunction with the * operator unzips a list:\n\nHaskell has a method of zipping sequences but requires a specific function for each arity (zip for two sequences, zip3 for three etc.), similarly the functions unzip and unzip3 are available for unzipping:\n\nLanguage comparison\nList of languages by support of zip:\n\nSee also\nMap (higher-order function)\n\n\n== References ==\n",
  "categories": [
    "Category:Articles with example Clojure code",
    "Category:Articles with example Haskell code",
    "Category:Articles with example Lisp (programming language) code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:Data mapping",
    "Category:Short description is different from Wikidata"
  ],
  "archived_date": "20241220_214804",
  "source_url": "https://en.wikipedia.org/wiki/Zipping_(computer_science)"
}