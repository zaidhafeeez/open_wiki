{
  "title": "Banker's algorithm",
  "summary": "Banker's algorithm is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an \"s-state\" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.\nThe algorithm was developed in the design process for the THE operating system and originally described (in ",
  "content": "---\ntitle: Banker's algorithm\nurl: https://en.wikipedia.org/wiki/Banker%27s_algorithm\nlanguage: en\ncategories: [\"Category:Articles with example Python (programming language) code\", \"Category:Articles with example pseudocode\", \"Category:Articles with short description\", \"Category:CS1 maint: multiple names: authors list\", \"Category:Concurrency control algorithms\", \"Category:Edsger W. Dijkstra\", \"Category:Short description is different from Wikidata\"]\nreferences: 0\nlast_modified: 2024-12-19T13:56:15Z\n---\n\n# Banker's algorithm\n\n## Summary\n\nBanker's algorithm is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an \"s-state\" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.\nThe algorithm was developed in the design process for the THE operating system and originally described (in \n\n## Full Content\n\nBanker's algorithm is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an \"s-state\" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.\nThe algorithm was developed in the design process for the THE operating system and originally described (in Dutch) in EWD108. When a new process enters a system, it must declare the maximum number of instances of each resource type that it may ever claim; clearly, that number may not exceed the total number of resources in the system. Also, when a process gets all its requested resources it must return them in a finite amount of time.\n\nResources\nFor the Banker's algorithm to work, it needs to know three things:\n\nHow much of each resource each process could possibly request (\"MAX\")\nHow much of each resource each process is currently holding (\"ALLOCATED\")\nHow much of each resource the system currently has available (\"AVAILABLE\")\nResources may be allocated to a process only if the amount of resources requested is less than or equal to the amount available; otherwise, the process waits until resources are available.\nSome of the resources that are tracked in real systems are memory, semaphores and interface access.\nThe Banker's algorithm derives its name from the fact that this algorithm could be used in a banking system to ensure that the bank does not run out of resources, because the bank would never allocate its money in such a way that it can no longer satisfy the needs of all its customers. By using the Banker's algorithm, the bank ensures that when customers request money the bank never leaves a safe state. If the customer's request does not cause the bank to leave a safe state, the cash will be allocated, otherwise the customer must wait until some other customer deposits enough.\nBasic data structures to be maintained to implement the Banker's algorithm:\nLet n be the number of processes in the system and m be the number of resource types. Then we need the following data structures:\n\nAvailable: A vector of length m indicates the number of available resources of each type. If Available[j] = k, there are k instances of resource type Rj available.\nMax: An n × m  matrix defines the maximum demand of each process. If Max[i,j] = k, then Pi may request at most k instances of resource type Rj.\nAllocation: An n × m  matrix defines the number of resources of each type currently allocated to each process. If Allocation[i,j] = k, then process Pi is currently allocated k instances of resource type Rj.\nNeed: An n × m  matrix indicates the remaining resource need of each process. If Need[i,j] = k, then Pi may need k more instances of resource type Rj to complete the task.\nNote: Need[i,j] = Max[i,j] - Allocation[i,j].\nn=m-a.\n\nExample\nTotal system resources are:\nA B C D\n6 5 7 6\n\nAvailable system resources are:\nA B C D\n3 1 1 2\n\nProcesses (currently allocated resources):\n   A B C D\nP1 1 2 2 1\nP2 1 0 3 3\nP3 1 2 1 0\n\nProcesses (maximum resources):\n   A B C D\nP1 3 3 2 2\nP2 1 2 3 4\nP3 1 3 5 0\n\nNeed = maximum resources - currently allocated resources\nProcesses (possibly needed resources):\n   A B C D\nP1 2 1 0 1\nP2 0 2 0 1\nP3 0 1 4 0\n\nSafe and unsafe states\nA state (as in the above example) is considered safe if it is possible for all processes to finish executing (terminate).  Since the system cannot know when a process will terminate, or how many resources it will have requested by then, the system assumes that all processes will eventually attempt to acquire their stated maximum resources and terminate soon afterward.  This is a reasonable assumption in most cases since the system is not particularly concerned with how long each process runs (at least not from a deadlock avoidance perspective).  Also, if a process terminates without acquiring its maximum resource it only makes it easier on the system.\nA safe state is considered to be the decision maker if it's going to process ready queue.\nGiven that assumption, the algorithm determines if a state is safe by trying to find a hypothetical set of requests by the processes that would allow each to acquire its maximum resources and then terminate (returning its resources to the system).  Any state where no such set exists is an unsafe state.\nWe can show that the state given in the previous example is a safe state by showing that it is possible for each process to acquire its maximum resources and then terminate.\n\nP1 needs 2 A, 1 B and 1 D more resources, achieving its maximum\n[available resource: ⟨3 1 1 2⟩ − ⟨2 1 0 1⟩ = ⟨1 0 1 1⟩]\nThe system now still has 1 A, no B, 1 C and 1 D resource available\nP1 terminates, returning 3 A, 3 B, 2 C and 2 D resources to the system\n[available resource: ⟨1 0 1 1⟩ + ⟨3 3 2 2⟩ = ⟨4 3 3 3⟩]\nThe system now has 4 A, 3 B, 3 C and 3 D resources available\nP2 acquires 2 B and 1 D extra resources, then terminates, returning all its resources\n[available resource: ⟨4 3 3 3⟩ − ⟨0 2 0 1⟩ + ⟨1 2 3 4⟩ = ⟨5 3 6 6⟩]\nThe system now has 5 A, 3 B, 6 C and 6 D resources\nP3 acquires 1 B and 4 C resources and terminates.\n[available resource: ⟨5 3 6 6⟩ − ⟨0 1 4 0⟩ + ⟨1 3 5 0⟩ = ⟨6 5 7 6⟩]\nThe system now has all resources: 6 A, 5 B, 7 C and 6 D\nBecause all processes were able to terminate, this state is safe\nFor an example of an unsafe state, consider what would happen if process 2 was holding 1 units of resource B at the beginning.\n\nRequests\nWhen the system receives a request for resources, it runs the Banker's algorithm to determine if it is safe to grant the request.  \nThe algorithm is fairly straightforward once the distinction between safe and unsafe states is understood.\n\nCan the request be granted?\nIf not, the request is impossible and must either be denied or put on a waiting list\nAssume that the request is granted\nIs the new state safe?\nIf so grant the request\nIf not, either deny the request or put it on a waiting list\nWhether the system denies or postpones an impossible or unsafe request is a decision specific to the operating system.\n\n    Example \n\nStarting in the same state as the previous example started in, assume process 1 requests 2 units of resource C.\n\nThere is not enough of resource C available to grant the request\nThe request is denied\n\nOn the other hand, assume process 3 requests 1 unit of resource C.\n\nThere are enough resources to grant the request\nAssume the request is granted\nThe new state of the system would be:\n    Available system resources\n     A B C D\nFree 3 1 0 2\n\n    Processes (currently allocated resources):\n     A B C D\nP1   1 2 2 1\nP2   1 0 3 3\nP3   1 2 2 0\n\n    Processes (maximum resources):\n     A B C D\nP1   3 3 2 2\nP2   1 2 3 4\nP3   1 3 5 0\n\nDetermine if this new state is safe\nP1 can acquire 2 A, 1 B and 1 D resources and terminate\nThen, P2 can acquire 2 B and 1 D resources and terminate\nFinally, P3 can acquire 1 B and 3 C resources and terminate\nTherefore, this new state is safe\nSince the new state is safe, grant the request\n\nFinal example: from the state we started at, assume that process 2 requests 1 unit of resource B.\n\nThere are enough resources\nAssuming the request is granted, the new state would be:\n    Available system resources:\n     A B C D\nFree 3 0 1 2\n\n    Processes (currently allocated resources):\n     A B C D\nP1   1 2 5 1\nP2   1 1 3 3\nP3   1 2 1 0\n\n    Processes (maximum resources):\n     A B C D\nP1   3 3 2 2\nP2   1 2 3 4\nP3   1 3 5 0\n\nIs this state safe?  Assuming P1, P2, and P3 request more of resource B and C.\nP1 is unable to acquire enough B resources\nP2 is unable to acquire enough B resources\nP3 is unable to acquire enough B resources\nNo process can acquire enough resources to terminate, so this state is not safe\nSince the state is unsafe, deny the request\n\nLimitations\nLike the other algorithms, the Banker's algorithm has some limitations when implemented.  Specifically, it needs to know how much of each resource a process could possibly request.  In most systems, this information is unavailable, making it impossible to implement the Banker's algorithm. Also, it is unrealistic to assume that the number of processes is static since in most systems the number of processes varies dynamically. Moreover, the requirement that a process will eventually release all its resources (when the process terminates) is sufficient for the correctness of the algorithm, however it is not sufficient for a practical system. Waiting for hours (or even days) for resources to be released is usually not acceptable.\n\nReferences\nFurther reading\n\"Operating System Concepts\" by Silberschatz, Galvin, and Gagne (pages 259-261 of the 7th edition)\n\"Operating System Concepts\" by Silberschatz, Galvin, and Gagne (pages 298-300 of the 8th edition)\nDijkstra, Edsger W. The mathematics behind the Banker's Algorithm (EWD-623) (PDF). E.W. Dijkstra Archive. Center for American History, University of Texas at Austin. (transcription) (1977), published as pages 308–312 of Edsger W. Dijkstra, Selected Writings on Computing: A Personal Perspective, Springer-Verlag, 1982. ISBN 0-387-90652-5\n",
  "categories": [
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with example pseudocode",
    "Category:Articles with short description",
    "Category:CS1 maint: multiple names: authors list",
    "Category:Concurrency control algorithms",
    "Category:Edsger W. Dijkstra",
    "Category:Short description is different from Wikidata"
  ],
  "archived_date": "20241220_214816",
  "source_url": "https://en.wikipedia.org/wiki/Banker%27s_algorithm"
}