{
  "title": "Rendezvous hashing",
  "summary": "Rendezvous or highest random weight (HRW) hashing is an algorithm that allows clients to achieve distributed agreement on a set of \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n options out of a possible set of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n options. A typical application is when clients need to agree on which sites (or proxies) objects are assigned to.\nConsistent hashing addresses the special case  \n  \n    \n      \n        k\n        =\n        1\n ",
  "content": "---\ntitle: Rendezvous hashing\nurl: https://en.wikipedia.org/wiki/Rendezvous_hashing\nlanguage: en\ncategories: [\"Category:Algorithms\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with short description\", \"Category:CS1 errors: missing periodical\", \"Category:Hashing\", \"Category:Short description matches Wikidata\"]\nreferences: 0\nlast_modified: 2024-12-19T14:37:09Z\n---\n\n# Rendezvous hashing\n\n## Summary\n\nRendezvous or highest random weight (HRW) hashing is an algorithm that allows clients to achieve distributed agreement on a set of \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n options out of a possible set of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n options. A typical application is when clients need to agree on which sites (or proxies) objects are assigned to.\nConsistent hashing addresses the special case  \n  \n    \n      \n        k\n        =\n        1\n \n\n## Full Content\n\nRendezvous or highest random weight (HRW) hashing is an algorithm that allows clients to achieve distributed agreement on a set of \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n options out of a possible set of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n options. A typical application is when clients need to agree on which sites (or proxies) objects are assigned to.\nConsistent hashing addresses the special case  \n  \n    \n      \n        k\n        =\n        1\n      \n    \n    {\\displaystyle k=1}\n  \n using a different method. Rendezvous hashing is both much simpler and more general than consistent hashing (see below).\n\nHistory\nRendezvous hashing was invented  by David Thaler and Chinya Ravishankar at the University of Michigan in 1996. Consistent hashing appeared a year later in the literature.\nGiven its simplicity and generality, rendezvous hashing is now being preferred to consistent hashing in real-world applications.  Rendezvous hashing was used very early on in many applications including mobile caching, router design, secure key establishment, and sharding and distributed databases. Other examples of real-world systems that use Rendezvous Hashing include the Github load balancer, the Apache Ignite distributed database, the Tahoe-LAFS file store, the CoBlitz large-file distribution service, Apache Druid, IBM's Cloud Object Store, the Arvados Data Management System, Apache Kafka, and the Twitter EventBus pub/sub platform.\nOne of the first applications of rendezvous hashing was to enable multicast clients on the Internet (in contexts such as the MBONE) to identify multicast rendezvous points in a distributed fashion. It was used in 1998 by Microsoft's Cache Array Routing Protocol (CARP) for distributed cache coordination and routing. Some Protocol Independent Multicast routing protocols use rendezvous hashing to pick a rendezvous point.\n\nProblem definition and approach\nAlgorithm\nRendezvous hashing solves a general version of the distributed hash table problem: We are given a set of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n sites (servers or proxies, say). How can any set of clients, given an object \n  \n    \n      \n        O\n      \n    \n    {\\displaystyle O}\n  \n, agree on a k-subset of sites to assign to \n  \n    \n      \n        O\n      \n    \n    {\\displaystyle O}\n  \n? The standard version of the problem uses k = 1. Each client is to make its selection independently, but all clients must end up picking the same subset of sites. This is non-trivial if we add a minimal disruption constraint, and require that when a site fails or is removed, only objects mapping to that site need be reassigned to other sites.\nThe basic idea is to give each site \n  \n    \n      \n        \n          S\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle S_{j}}\n  \n a score (a weight) for each object \n  \n    \n      \n        \n          O\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle O_{i}}\n  \n, and assign the object to the highest scoring site. All clients first agree on a hash function \n  \n    \n      \n        h\n        (\n        ⋅\n        )\n      \n    \n    {\\displaystyle h(\\cdot )}\n  \n. For object \n  \n    \n      \n        \n          O\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle O_{i}}\n  \n, the site \n  \n    \n      \n        \n          S\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle S_{j}}\n  \n is defined to have weight \n  \n    \n      \n        \n          w\n          \n            i\n            ,\n            j\n          \n        \n        =\n        h\n        (\n        \n          O\n          \n            i\n          \n        \n        ,\n        \n          S\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle w_{i,j}=h(O_{i},S_{j})}\n  \n. Each client independently computes these weights \n  \n    \n      \n        \n          w\n          \n            i\n            ,\n            1\n          \n        \n        ,\n        \n          w\n          \n            i\n            ,\n            2\n          \n        \n        …\n        \n          w\n          \n            i\n            ,\n            n\n          \n        \n      \n    \n    {\\displaystyle w_{i,1},w_{i,2}\\dots w_{i,n}}\n  \n and picks the k sites that yield the k largest hash values. The clients have thereby achieved distributed \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n-agreement.\nIf a site \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n is added or removed, only the objects mapping to \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n are remapped to different sites, satisfying the minimal disruption constraint above. The HRW assignment can be computed independently by any client, since it depends only on the identifiers for the set of sites \n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n        ,\n        \n          S\n          \n            2\n          \n        \n        …\n        \n          S\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle S_{1},S_{2}\\dots S_{n}}\n  \n and the object being assigned.\nHRW easily accommodates different capacities among sites. If site \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n has twice the capacity of the other sites, we simply represent \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n twice in the list, say, as \n  \n    \n      \n        \n          S\n          \n            k\n            ,\n            1\n          \n        \n        ,\n        \n          S\n          \n            k\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle S_{k,1},S_{k,2}}\n  \n. Clearly, twice as many objects will now map to \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n as to the other sites.\n\nProperties\nConsider the simple version of the problem, with k = 1, where all clients are to agree on a single site for an object O. Approaching the problem naively, it might appear sufficient to treat the n sites as buckets in a hash table and hash the object name O into this table. Unfortunately, if any of the sites fails or is unreachable, the hash table size changes, forcing all objects to be remapped. This massive disruption makes such direct hashing unworkable.\nUnder rendezvous hashing, however, clients handle site failures by picking the site that yields the next largest weight. Remapping is required only for objects currently mapped to the failed site, and disruption is minimal.\nRendezvous hashing has the following properties:\n\nLow overhead: The hash function used is efficient, so overhead at the clients is very low.\nLoad balancing: Since the hash function is randomizing, each of the n sites is equally likely to receive the object O. Loads are uniform across the sites.\nSite capacity: Sites with different capacities can be represented in the site list with multiplicity in proportion to capacity. A site with twice the capacity of the other sites will be represented twice in the list, while every other site is represented once.\nHigh hit rate: Since all clients agree on placing an object O into the same site SO, each fetch or placement of O into SO yields the maximum utility in terms of hit rate. The object O will always be found unless it is evicted by some replacement algorithm at SO.\nMinimal disruption: When a site fails, only the objects mapped to that site need to be remapped. Disruption is at the minimal possible level, as proved in.\nDistributed k-agreement: Clients can reach distributed agreement on k sites simply by selecting the top k sites in the ordering.\n\nO(log n) running time via skeleton-based hierarchical rendezvous hashing\nThe standard version of Rendezvous Hashing described above works quite well for moderate n, but when \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n is extremely large, the hierarchical use of Rendezvous Hashing achieves \n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(\\log n)}\n  \n running time. This approach creates a virtual hierarchical structure (called a \"skeleton\"), and achieves \n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(\\log n)}\n  \n running time by applying HRW at each level while descending the hierarchy. The idea is to first choose some constant \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n and organize the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n sites into \n  \n    \n      \n        c\n        =\n        ⌈\n        n\n        \n          /\n        \n        m\n        ⌉\n      \n    \n    {\\displaystyle c=\\lceil n/m\\rceil }\n  \n clusters \n  \n    \n      \n        \n          C\n          \n            1\n          \n        \n        =\n        \n          {\n          \n            \n              S\n              \n                1\n              \n            \n            ,\n            \n              S\n              \n                2\n              \n            \n            …\n            \n              S\n              \n                m\n              \n            \n          \n          }\n        \n        ,\n        \n          C\n          \n            2\n          \n        \n        =\n        \n          {\n          \n            \n              S\n              \n                m\n                +\n                1\n              \n            \n            ,\n            \n              S\n              \n                m\n                +\n                2\n              \n            \n            …\n            \n              S\n              \n                2\n                m\n              \n            \n          \n          }\n        \n        …\n      \n    \n    {\\displaystyle C_{1}=\\left\\{S_{1},S_{2}\\dots S_{m}\\right\\},C_{2}=\\left\\{S_{m+1},S_{m+2}\\dots S_{2m}\\right\\}\\dots }\n  \n Next, build a virtual hierarchy by choosing a constant \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n and imagining these \n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n  \n clusters placed at the leaves of a tree \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n of virtual nodes, each with fanout \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n.\n\nIn the accompanying diagram, the cluster size is \n  \n    \n      \n        m\n        =\n        4\n      \n    \n    {\\displaystyle m=4}\n  \n, and the skeleton fanout is \n  \n    \n      \n        f\n        =\n        3\n      \n    \n    {\\displaystyle f=3}\n  \n. Assuming 108 sites (real nodes) for convenience, we get a three-tier virtual hierarchy. Since \n  \n    \n      \n        f\n        =\n        3\n      \n    \n    {\\displaystyle f=3}\n  \n, each virtual node has a natural numbering in octal. Thus, the 27 virtual nodes at the lowest tier would be numbered \n  \n    \n      \n        000\n        ,\n        001\n        ,\n        002\n        ,\n        .\n        .\n        .\n        ,\n        221\n        ,\n        222\n      \n    \n    {\\displaystyle 000,001,002,...,221,222}\n  \n in octal (we can, of course, vary the fanout at each level - in that case, each node will be identified with the corresponding mixed-radix number).\nThe easiest way to understand the virtual hierarchy is by starting at the top, and descending the virtual hierarchy. We successively apply Rendezvous Hashing to the set of virtual nodes at each level of the hierarchy, and descend the branch defined by the winning virtual node. We can in fact start at any level in the virtual hierarchy. Starting lower in the hierarchy requires more hashes, but may improve load distribution in the case of failures.\nFor example, instead of applying HRW to all 108 real nodes in the diagram, we can first apply HRW to the 27 lowest-tier virtual nodes, selecting one. We then apply HRW to the four real nodes in its cluster, and choose the winning site. We only need \n  \n    \n      \n        27\n        +\n        4\n        =\n        31\n      \n    \n    {\\displaystyle 27+4=31}\n  \n hashes, rather than 108. If we apply this method starting one level higher in the hierarchy, we would need \n  \n    \n      \n        9\n        +\n        3\n        +\n        4\n        =\n        16\n      \n    \n    {\\displaystyle 9+3+4=16}\n  \n hashes to get to the winning site. The figure shows how, if we proceed starting from the root of the skeleton, we may successively choose the virtual nodes \n  \n    \n      \n        (\n        2\n        \n          )\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle (2)_{3}}\n  \n, \n  \n    \n      \n        (\n        20\n        \n          )\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle (20)_{3}}\n  \n, and \n  \n    \n      \n        (\n        200\n        \n          )\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle (200)_{3}}\n  \n, and finally end up with site 74.\nThe virtual hierarchy need not be stored, but can be created on demand, since the virtual nodes names are simply prefixes of base-\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n (or mixed-radix) representations. We can easily create appropriately sorted strings from the digits, as required. In the example, we would be working with the strings \n  \n    \n      \n        0\n        ,\n        1\n        ,\n        2\n      \n    \n    {\\displaystyle 0,1,2}\n  \n (at tier 1), \n  \n    \n      \n        20\n        ,\n        21\n        ,\n        22\n      \n    \n    {\\displaystyle 20,21,22}\n  \n (at tier 2), and \n  \n    \n      \n        200\n        ,\n        201\n        ,\n        202\n      \n    \n    {\\displaystyle 200,201,202}\n  \n (at tier 3). Clearly, \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n has height \n  \n    \n      \n        h\n        =\n        O\n        (\n        log\n        ⁡\n        c\n        )\n        =\n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle h=O(\\log c)=O(\\log n)}\n  \n, since \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n and \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n are both constants. The work done at each level is \n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n, since \n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n is a constant.\nThe value of \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n can be chosen based on factors like the anticipated failure rate and the degree of desired load balancing. A higher value of \n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n leads to less load skew in the event of failure at the cost of higher search overhead.\nThe choice \n  \n    \n      \n        m\n        =\n        n\n      \n    \n    {\\displaystyle m=n}\n  \n is equivalent to non-hierarchical rendezvous hashing. In practice, the hash function \n  \n    \n      \n        h\n        (\n        ⋅\n        )\n      \n    \n    {\\displaystyle h(\\cdot )}\n  \n is very cheap, so \n  \n    \n      \n        m\n        =\n        n\n      \n    \n    {\\displaystyle m=n}\n  \n can work quite well unless \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n is very high.\nFor any given object, it is clear that each leaf-level cluster, and hence each of the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n sites, is chosen with equal probability.\n\nReplication, site failures, and site additions\nOne can enhance resiliency to failures by replicating each object O across the highest ranking r < m sites for O, choosing r based on the level of resiliency desired. The simplest strategy is to replicate only within the leaf-level cluster.\nIf the leaf-level site selected for O is unavailable, we select the next-ranked site for O within the same leaf-level cluster. If O has been replicated within the leaf-level cluster, we are sure to find O in the next available site in the ranked order of r sites. All objects that were held by the failed server appear in some other site in its cluster. (Another option is to go up one or more tiers in the skeleton and select an alternate from among the sibling virtual nodes at that tier. We then descend the hierarchy to the real nodes, as above.)\nWhen a site is added to the system, it may become the winning site for some objects already assigned to other sites. Objects mapped to other clusters will never map to this new site, so we need to only consider objects held by other sites in its cluster. If the sites are caches, attempting to access an object mapped to the new site will result in a cache miss, the corresponding object will be fetched and cached, and operation returns to normal.\nIf sites are servers, some objects must be remapped to this newly added site.  As before, objects mapped to other clusters will never map to this new site, so we need to only consider objects held by sites in its cluster. That is, we need only remap objects currently present in the m sites in this local cluster, rather than the entire set of objects in the system. New objects mapping to this site will of course be automatically assigned to it.\n\nComparison with consistent hashing\nBecause of its simplicity, lower overhead, and generality (it works for any k < n), rendezvous hashing is increasingly being preferred over consistent hashing. Recent examples of its use include the Github load balancer, the Apache Ignite distributed database, and by the Twitter EventBus pub/sub platform.\nConsistent hashing operates by mapping sites uniformly and randomly to points on a unit circle called tokens. Objects are also mapped to the unit circle and placed in the site whose token is the first encountered traveling clockwise from the object's location. When a site is removed, the objects it owns are transferred to the site owning the next token encountered moving clockwise. Provided each site is mapped to a large number (100–200, say) of tokens this will reassign objects in a relatively uniform fashion among the remaining sites.\nIf sites are mapped to points on the circle randomly by hashing 200 variants of the site ID, say, the assignment of any object requires storing or recalculating 200 hash values for each site. However, the tokens associated with a given site can be precomputed and stored in a sorted list, requiring only a single application of the hash function to the object, and a binary search to compute the assignment. Even with many tokens per site, however, the basic version of consistent hashing may not balance objects uniformly over sites, since when a site is removed each object assigned to it is distributed only over as many other sites as the site has tokens (say 100–200).\nVariants of consistent hashing (such as Amazon's Dynamo) that use more complex logic to distribute tokens on the unit circle offer better load balancing than basic consistent hashing, reduce the overhead of adding new sites, and reduce metadata overhead and offer other benefits.\n\nAdvantages of Rendezvous hashing over consistent hashing\nRendezvous hashing (HRW) is much simpler conceptually and in practice. It also distributes objects uniformly over all sites, given a uniform hash function. Unlike consistent hashing, HRW requires no precomputing or storage of tokens. Consider k =1. An object \n  \n    \n      \n        \n          O\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle O_{i}}\n  \n is placed into one of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n sites \n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n        ,\n        \n          S\n          \n            2\n          \n        \n        …\n        \n          S\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle S_{1},S_{2}\\dots S_{n}}\n  \n by computing the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n hash values \n  \n    \n      \n        h\n        (\n        \n          O\n          \n            i\n          \n        \n        ,\n        \n          S\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle h(O_{i},S_{j})}\n  \n and picking the site \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n that yields the highest hash value. If a new site \n  \n    \n      \n        \n          S\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle S_{n+1}}\n  \n is added, new object placements or requests will compute \n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n hash values, and pick the largest of these. If an object already in the system at \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n maps to this new site \n  \n    \n      \n        \n          S\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle S_{n+1}}\n  \n, it will be fetched afresh and cached at \n  \n    \n      \n        \n          S\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle S_{n+1}}\n  \n. All clients will henceforth obtain it from this site, and the old cached copy at \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n will ultimately be replaced by the local cache management algorithm. If \n  \n    \n      \n        \n          S\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle S_{k}}\n  \n is taken offline, its objects will be remapped uniformly to the remaining \n  \n    \n      \n        n\n        −\n        1\n      \n    \n    {\\displaystyle n-1}\n  \n sites.\nVariants of the HRW algorithm, such as the use of a skeleton (see below), can reduce the \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n time for object location to \n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(\\log n)}\n  \n, at the cost of less global uniformity of placement. When \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n is not too large, however, the \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n placement cost of basic HRW is not likely to be a problem. HRW completely avoids all the overhead and complexity associated with correctly handling multiple tokens for each site and associated metadata.\nRendezvous hashing also has the great advantage that it provides simple solutions to other important problems, such as distributed \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n-agreement.\n\nConsistent hashing is a special case of Rendezvous hashing\nRendezvous hashing is both simpler and more general than consistent hashing. Consistent hashing can be shown to be a special case of HRW by an appropriate choice of a two-place hash function. From the site identifier \n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n the simplest version of consistent hashing computes a list of token positions, e.g., \n  \n    \n      \n        \n          t\n          \n            s\n          \n        \n        =\n        \n          h\n          \n            c\n          \n        \n        (\n        S\n        )\n      \n    \n    {\\displaystyle t_{s}=h_{c}(S)}\n  \n where \n  \n    \n      \n        \n          h\n          \n            c\n          \n        \n      \n    \n    {\\displaystyle h_{c}}\n  \n hashes values to locations on the unit circle. Define the two place hash function \n  \n    \n      \n        h\n        (\n        S\n        ,\n        O\n        )\n      \n    \n    {\\displaystyle h(S,O)}\n  \n to be \n  \n    \n      \n        \n          \n            1\n            \n              \n                min\n                \n                  S\n                \n              \n              (\n              \n                h\n                \n                  c\n                \n              \n              (\n              O\n              )\n              −\n              \n                t\n                \n                  s\n                \n              \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\min _{S}(h_{c}(O)-t_{s})}}}\n  \n where \n  \n    \n      \n        \n          h\n          \n            c\n          \n        \n        (\n        O\n        )\n        −\n        \n          t\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle h_{c}(O)-t_{s}}\n  \n denotes the distance along the unit circle from \n  \n    \n      \n        \n          h\n          \n            c\n          \n        \n        (\n        O\n        )\n      \n    \n    {\\displaystyle h_{c}(O)}\n  \n to \n  \n    \n      \n        \n          t\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle t_{s}}\n  \n (since \n  \n    \n      \n        \n          h\n          \n            c\n          \n        \n        (\n        O\n        )\n        −\n        \n          t\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle h_{c}(O)-t_{s}}\n  \n has some minimal non-zero value there is no problem translating this value to a unique integer in some bounded range). This will duplicate exactly the assignment produced by consistent hashing.\nIt is not possible, however, to reduce HRW to consistent hashing (assuming the number of tokens per site is bounded), since HRW potentially reassigns the objects from a removed site to an unbounded number of other sites.\n\nWeighted variations\nIn the standard implementation of rendezvous hashing, every node receives a statically equal proportion of the keys. This behavior, however, is undesirable when the nodes have different capacities for processing or holding their assigned keys. For example, if one of the nodes had twice the storage capacity as the others, it would be beneficial if the algorithm could take this into account such that this more powerful node would receive twice the number of keys as each of the others.\nA straightforward mechanism to handle this case is to assign two virtual locations to this node, so that if either of that larger node's virtual locations has the highest hash, that node receives the key. But this strategy does not work when the relative weights are not integer multiples. For example, if one node had 42% more storage capacity, it would require adding many virtual nodes in different proportions, leading to greatly reduced performance. Several modifications to rendezvous hashing have been proposed to overcome this limitation.\n\nCache Array Routing Protocol\nThe Cache Array Routing Protocol (CARP) is a 1998 IETF draft that describes a method for computing load factors which can be multiplied by each node's hash score to yield an arbitrary level of precision for weighting nodes differently. However, one disadvantage of this approach is that when any node's weight is changed, or when any node is added or removed, all the load factors must be re-computed and relatively scaled. When the load factors change relative to one another, it triggers movement of keys between nodes whose weight was not changed, but whose load factor did change relative to other nodes in the system. This results in excess movement of keys.\n\nControlled replication\nControlled replication under scalable hashing or CRUSH is an extension to RUSH that improves upon rendezvous hashing by constructing a tree where a pseudo-random function (hash) is used to navigate down the tree to find which node is ultimately responsible for a given key. It permits perfect stability for adding nodes; however, it is not perfectly stable when removing or re-weighting nodes, with the excess movement of keys being proportional to the height of the tree.\nThe CRUSH algorithm is used by the ceph data storage system to map data objects to the nodes responsible for storing them.\n\nOther variants\nIn 2005, Christian Schindelhauer and Gunnar Schomaker described a logarithmic method for re-weighting hash scores in a way that does not require relative scaling of load factors when a node's weight changes or when nodes are added or removed. This enabled the dual benefits of perfect precision when weighting nodes, along with perfect stability, as only a minimum number of keys needed to be remapped to new nodes.\nA similar logarithm-based hashing strategy is used to assign data to storage nodes in Cleversafe's data storage system, now IBM Cloud Object Storage.\n\nSystems using Rendezvous hashing\nRendezvous hashing is being used widely in real-world systems. A partial list includes Oracle's Database in-memory, the GitHub load balancer, the Apache Ignite distributed database, the Tahoe-LAFS file store, the CoBlitz large-file distribution service, Apache Druid, IBM's Cloud Object Store, the Arvados Data Management System, Apache Kafka, and by the Twitter EventBus pub/sub platform.\n\nImplementation\nImplementation is straightforward once a hash function \n  \n    \n      \n        h\n        (\n        ⋅\n        )\n      \n    \n    {\\displaystyle h(\\cdot )}\n  \n is chosen (the original work on the HRW method makes a hash function recommendation). Each client only needs to compute a hash value for each of the \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n sites, and then pick the largest. This algorithm runs in \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n time. If the hash function is efficient, the \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n running time is not a problem unless \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n is very large.\n\nWeighted rendezvous hash\nPython code implementing a weighted rendezvous hash:\n\nExample outputs of WRH:\n\nReferences\nExternal links\nRendezvous Hashing: an alternative to Consistent Hashing\n",
  "categories": [
    "Category:Algorithms",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with short description",
    "Category:CS1 errors: missing periodical",
    "Category:Hashing",
    "Category:Short description matches Wikidata"
  ],
  "archived_date": "20241221_183016",
  "source_url": "https://en.wikipedia.org/wiki/Rendezvous_hashing"
}