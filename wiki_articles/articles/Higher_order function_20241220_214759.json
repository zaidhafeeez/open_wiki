{
  "title": "Higher-order function",
  "summary": "In mathematics and computer science, a higher-order function (HOF) is a function that does at least one of the following:\ntakes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a procedure that is itself a procedure),\nreturns a function or value as its result.\nAll other functions are first-order functions. In mathematics higher-order functions are also termed operators or functionals. The differential operator in calculus is a common example, since it maps",
  "content": "---\ntitle: Higher-order function\nurl: https://en.wikipedia.org/wiki/Higher-order_function\nlanguage: en\ncategories: [\"Category:All articles needing additional references\", \"Category:Articles needing additional references from November 2024\", \"Category:Articles with example C++ code\", \"Category:Articles with example C code\", \"Category:Articles with example D code\", \"Category:Articles with example Haskell code\", \"Category:Articles with example JavaScript code\", \"Category:Articles with example Java code\", \"Category:Articles with example Julia code\", \"Category:Articles with example Lisp (programming language) code\", \"Category:Articles with example MATLAB/Octave code\", \"Category:Articles with example PHP code\", \"Category:Articles with example Pascal code\", \"Category:Articles with example Perl code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with example R code\", \"Category:Articles with example Scala code\", \"Category:Articles with example Scheme (programming language) code\", \"Category:Articles with example Swift code\", \"Category:Articles with example Tcl code\", \"Category:Articles with short description\", \"Category:Functional programming\", \"Category:Higher-order functions\", \"Category:Lambda calculus\", \"Category:Short description is different from Wikidata\", \"Category:Subroutines\"]\nreferences: 0\nlast_modified: 2024-12-19T13:43:36Z\n---\n\n# Higher-order function\n\n## Summary\n\nIn mathematics and computer science, a higher-order function (HOF) is a function that does at least one of the following:\ntakes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a procedure that is itself a procedure),\nreturns a function or value as its result.\nAll other functions are first-order functions. In mathematics higher-order functions are also termed operators or functionals. The differential operator in calculus is a common example, since it maps\n\n## Full Content\n\nIn mathematics and computer science, a higher-order function (HOF) is a function that does at least one of the following:\ntakes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a procedure that is itself a procedure),\nreturns a function or value as its result.\nAll other functions are first-order functions. In mathematics higher-order functions are also termed operators or functionals. The differential operator in calculus is a common example, since it maps a function to its derivative, also a function. Higher-order functions should not be confused with other uses of the word \"functor\" throughout mathematics, see Functor (disambiguation).\nIn the untyped lambda calculus, all functions are higher-order; in a typed lambda calculus, from which most functional programming languages are derived, higher-order functions that take one function as argument are values with types of the form \n  \n    \n      \n        (\n        \n          τ\n          \n            1\n          \n        \n        →\n        \n          τ\n          \n            2\n          \n        \n        )\n        →\n        \n          τ\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle (\\tau _{1}\\to \\tau _{2})\\to \\tau _{3}}\n  \n.\n\nGeneral examples\nmap function, found in many functional programming languages, is one example of a higher-order function. It takes as arguments a function f and a collection of elements, and as the result, returns a new collection with f applied to each element from the collection.\nSorting functions, which take a comparison function as a parameter, allowing the programmer to separate the sorting algorithm from the comparisons of the items being sorted. The C standard function qsort is an example of this.\n filter\nfold\napply\nFunction composition\nIntegration\n Callback\nTree traversal\nMontague grammar, a semantic theory of natural language, uses higher-order functions\n\nSupport in programming languages\nDirect support\nThe examples are not intended to compare and contrast programming languages, but to serve as examples of higher-order function syntax\nIn the following examples, the higher-order function twice takes a function, and applies the function to some value twice. If twice has to be applied several times for the same f it preferably should return a function rather than a value. This is in line with the \"don't repeat yourself\" principle.\n\nAPL\nOr in a tacit manner:\n\nC++\nUsing std::function in C++11:\n\nOr, with generic lambdas provided by C++14:\n\nC#\nUsing just delegates:\n\nOr equivalently, with static methods:\n\nClojure\nColdFusion Markup Language (CFML)\nCommon Lisp\nD\nDart\nElixir\nIn Elixir, you can mix module definitions and anonymous functions\n\nAlternatively, we can also compose using pure anonymous functions.\n\nErlang\nIn this Erlang example, the higher-order function or_else/2 takes a list of functions (Fs) and argument (X). It evaluates the function F with the argument X as argument. If the function F returns false then the next function in Fs will be evaluated. If the function F returns {false, Y} then the next function in Fs with argument Y will be evaluated. If the function F returns R the higher-order function or_else/2 will return R. Note that X, Y, and R can be functions. The example returns false.\n\nF#\nGo\nNotice a function literal can be defined either with an identifier (twice) or anonymously (assigned to variable plusThree).\n\nGroovy\nHaskell\nJ\nExplicitly,\n\nor tacitly,\n\nJava (1.8+)\nUsing just functional interfaces:\n\nOr equivalently, with static methods:\n\nJavaScript\nWith arrow functions:\n\nOr with classical syntax:\n\nJulia\nKotlin\nLua\nMATLAB\nOCaml\nPHP\nor with all functions in variables:\n\nNote that arrow functions implicitly capture any variables that come from the parent scope, whereas anonymous functions require the use keyword to do the same.\n\nPerl\nor with all functions in variables:\n\nPython\nPython decorator syntax is often used to replace a function with the result of passing that function through a higher-order function. E.g., the function g could be implemented equivalently:\n\nR\nRaku\nIn Raku, all code objects are closures and therefore can reference inner \"lexical\" variables from an outer scope because the lexical variable is \"closed\" inside of the function. Raku also supports \"pointy block\" syntax for lambda expressions which can be assigned to a variable or invoked anonymously.\n\nRuby\nRust\nScala\nScheme\nSwift\nTcl\nTcl uses apply command to apply an anonymous function (since 8.6).\n\nXACML\nThe XACML standard defines higher-order functions in the standard to apply a function to multiple values of attribute bags.\n\nThe list of higher-order functions in XACML can be found here.\n\nXQuery\nAlternatives\nFunction pointers\nFunction pointers in languages such as C, C++, Fortran, and Pascal allow programmers to pass around references to functions. The following C code computes an approximation of the integral of an arbitrary function:\n\nThe qsort function from the C standard library uses a function pointer to emulate the behavior of a higher-order function.\n\nMacros\nMacros can also be used to achieve some of the effects of higher-order functions. However, macros cannot easily avoid the problem of variable capture; they may also result in large amounts of duplicated code, which can be more difficult for a compiler to optimize. Macros are generally not strongly typed, although they may produce strongly typed code.\n\nDynamic code evaluation\nIn other imperative programming languages, it is possible to achieve some of the same algorithmic results as are obtained via higher-order functions by dynamically executing code (sometimes called Eval or Execute operations) in the scope of evaluation. There can be significant drawbacks to this approach:\n\nThe argument code to be executed is usually not statically typed; these languages generally rely on dynamic typing to determine the well-formedness and safety of the code to be executed.\nThe argument is usually provided as a string, the value of which may not be known until run-time. This string must either be compiled during program execution (using just-in-time compilation) or evaluated by interpretation, causing some added overhead at run-time, and usually generating less efficient code.\n\nObjects\nIn object-oriented programming languages that do not support higher-order functions, objects can be an effective substitute. An object's methods act in essence like functions, and a method may accept objects as parameters and produce objects as return values. Objects often carry added run-time overhead compared to pure functions, however, and added boilerplate code for defining and instantiating an object and its method(s). Languages that permit stack-based (versus heap-based) objects or structs can provide more flexibility with this method.\nAn example of using a simple stack based record in Free Pascal with a function that returns a function:\n\nThe function a() takes a Txy record as input and returns the integer value of the sum of the record's x and y fields (3 + 7).\n\nDefunctionalization\nDefunctionalization can be used to implement higher-order functions in languages that lack  first-class functions:\n\nIn this case, different types are used to trigger different functions via function overloading. The overloaded function in this example has the signature auto apply.\n\nSee also\nFirst-class function\nCombinatory logic\nFunction-level programming\nFunctional programming\nKappa calculus - a formalism for functions which excludes higher-order functions\nStrategy pattern\nHigher order messages\n\n\n== References ==\n",
  "categories": [
    "Category:All articles needing additional references",
    "Category:Articles needing additional references from November 2024",
    "Category:Articles with example C++ code",
    "Category:Articles with example C code",
    "Category:Articles with example D code",
    "Category:Articles with example Haskell code",
    "Category:Articles with example JavaScript code",
    "Category:Articles with example Java code",
    "Category:Articles with example Julia code",
    "Category:Articles with example Lisp (programming language) code",
    "Category:Articles with example MATLAB/Octave code",
    "Category:Articles with example PHP code",
    "Category:Articles with example Pascal code",
    "Category:Articles with example Perl code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with example R code",
    "Category:Articles with example Scala code",
    "Category:Articles with example Scheme (programming language) code",
    "Category:Articles with example Swift code",
    "Category:Articles with example Tcl code",
    "Category:Articles with short description",
    "Category:Functional programming",
    "Category:Higher-order functions",
    "Category:Lambda calculus",
    "Category:Short description is different from Wikidata",
    "Category:Subroutines"
  ],
  "archived_date": "20241220_214759",
  "source_url": "https://en.wikipedia.org/wiki/Higher-order_function"
}