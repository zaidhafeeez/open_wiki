{
  "title": "Visitor pattern",
  "summary": "A visitor pattern is a software design pattern that separates the algorithm from the object structure. Because of this separation, new operations can be added to existing object structures without modifying the structures. It is one way to follow the open/closed principle in object-oriented programming and software engineering. \nIn essence, the visitor allows adding new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created that implements al",
  "content": "---\ntitle: Visitor pattern\nurl: https://en.wikipedia.org/wiki/Visitor_pattern\nlanguage: en\ncategories: [\"Category:All articles needing additional references\", \"Category:Articles needing additional references from January 2022\", \"Category:Articles with example C++ code\", \"Category:Articles with example C Sharp code\", \"Category:Articles with example Java code\", \"Category:Articles with example Lisp (programming language) code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with example Smalltalk code\", \"Category:Articles with short description\", \"Category:CS1 maint: multiple names: authors list\", \"Category:Commons category link from Wikidata\", \"Category:Programming language comparisons\", \"Category:Short description is different from Wikidata\", \"Category:Software design patterns\", \"Category:Webarchive template wayback links\"]\nreferences: 0\nlast_modified: 2024-12-19T13:42:16Z\n---\n\n# Visitor pattern\n\n## Summary\n\nA visitor pattern is a software design pattern that separates the algorithm from the object structure. Because of this separation, new operations can be added to existing object structures without modifying the structures. It is one way to follow the open/closed principle in object-oriented programming and software engineering. \nIn essence, the visitor allows adding new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created that implements al\n\n## Full Content\n\nA visitor pattern is a software design pattern that separates the algorithm from the object structure. Because of this separation, new operations can be added to existing object structures without modifying the structures. It is one way to follow the open/closed principle in object-oriented programming and software engineering. \nIn essence, the visitor allows adding new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created that implements all of the appropriate specializations of the virtual function. The visitor takes the instance reference as input, and implements the goal through double dispatch.\nProgramming languages with sum types and pattern matching obviate many of the benefits of the visitor pattern, as the visitor class is able to both easily branch on the type of the object and generate a compiler error if a new object type is defined which the visitor does not yet handle.\n\nOverview\nThe Visitor  \n\ndesign pattern is one of the twenty-three well-known Gang of Four design patterns \nthat describe how to solve recurring design problems to design flexible and reusable object-oriented software, that is, \nobjects that are easier to implement, change, test, and reuse.\n\nWhat problems can the Visitor design pattern solve?\nIt should be possible to define a new operation for (some) classes of an object structure without changing the classes.\nWhen new operations are needed frequently and the object structure consists of many unrelated classes,\nit's inflexible to add new subclasses each time a new operation is required\nbecause \"[..] distributing all these operations across the various node classes leads to a system that's hard to understand, maintain, and change.\"\n\nWhat solution does the Visitor design pattern describe?\nDefine a separate (visitor) object that implements an operation to be performed on elements of an object structure.\nClients traverse the object structure and call a dispatching operation accept (visitor) on an element — that \"dispatches\" (delegates) the request to the \"accepted visitor object\". The visitor object then performs the operation on the element (\"visits the element\").\nThis makes it possible to create new operations independently from the classes of an object structure\nby adding new visitor objects.\nSee also the UML class and sequence diagram below.\n\nDefinition\nThe Gang of Four defines the Visitor as:\n\nRepresent[ing] an operation to be performed on elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.\nThe nature of the Visitor makes it an ideal pattern to plug into public APIs, thus allowing its clients to perform operations on a class using a \"visiting\" class without having to modify the source.\n\nAdvantages\nMoving operations into visitor classes is beneficial when\n\nmany unrelated operations on an object structure are required,\nthe classes that make up the object structure are known and not expected to change,\nnew operations need to be added frequently,\nan algorithm involves several classes of the object structure, but it is desired to manage it in one single location,\nan algorithm needs to work across several independent class hierarchies.\nA drawback to this pattern, however, is that it makes extensions to the class hierarchy more difficult, as new classes typically require a new visit method to be added to each visitor.\n\nApplication\nConsider the design of a 2D computer-aided design (CAD) system. At its core, there are several types to represent basic geometric shapes like circles, lines, and arcs. The entities are ordered into layers, and at the top of the type hierarchy is the drawing, which is simply a list of layers, plus some added properties.\nA fundamental operation on this type hierarchy is saving a drawing to the system's native file format. At first glance, it may seem acceptable to add local save methods to all types in the hierarchy. But it is also useful to be able to save drawings to other file formats. Adding ever more methods for saving into many different file formats soon clutters the relatively pure original geometric data structure.\nA naive way to solve this would be to maintain separate functions for each file format. Such a save function would take a drawing as input, traverse it, and encode into that specific file format. As this is done for each added different format, duplication between the functions accumulates. For example, saving a circle shape in a raster format requires very similar code no matter what specific raster form is used, and is different from other primitive shapes. The case for other primitive shapes like lines and polygons is similar. Thus, the code becomes a large outer loop traversing through the objects, with a large decision tree inside the loop querying the type of the object. Another problem with this approach is that it is very easy to miss a shape in one or more savers, or a new primitive shape is introduced, but the save routine is implemented only for one file type and not others, leading to code extension and maintenance problems. As the versions of the same file grows it becomes more complicated to maintain it.\nInstead, the visitor pattern can be applied. It encodes the logical operation (i.e. save(image_tree)) on the whole hierarchy into one class (i.e. Saver) that implements the common methods for traversing the tree and describes virtual helper methods (i.e. save_circle, save_square, etc.) to be implemented for format specific behaviors. In the case of the CAD example, such format specific behaviors would be implemented by a subclass of Visitor (i.e. SaverPNG). As such, all duplication of type checks and traversal steps is removed. Additionally, the compiler now complains if a shape is omitted since it is now expected by the common base traversal/save function.\n\nIteration loops\nThe visitor pattern may be used for iteration over container-like data structures just like Iterator pattern but with limited functionality.: 288  For example, iteration over a directory structure could be implemented by a function class instead of more conventional loop pattern. This would allow deriving various useful information from directories content by implementing a visitor functionality for every item while reusing the iteration code. It's widely employed in Smalltalk systems and can be found in C++ as well.: 289  A drawback of this approach, however, is that you can't break out of the loop easily or iterate concurrently (in parallel i.e. traversing two containers at the same time by a single i variable).: 289  The latter would require writing additional functionality for a visitor to support these features.: 289\n\nStructure\nUML class and sequence diagram\nIn the UML class diagram above, the ElementA class doesn't implement a new operation directly.\nInstead, ElementA implements a dispatching operation  accept(visitor) that \"dispatches\" (delegates) a request to the \"accepted visitor object\" (visitor.visitElementA(this)). The Visitor1 class implements the operation (visitElementA(e:ElementA)).\n\nElementB then implements accept(visitor) by dispatching to visitor.visitElementB(this). The Visitor1 class implements the operation (visitElementB(e:ElementB)).\nThe UML sequence diagram\nshows the run-time interactions: The Client object traverses the elements of an object structure (ElementA,ElementB) and calls accept(visitor) on each element.\n\nFirst, the Client calls accept(visitor) on\nElementA, which calls visitElementA(this) on the accepted visitor object.\nThe element itself (this) is passed to the visitor so that \nit can \"visit\" ElementA (call operationA()).\n\nThereafter, the Client calls accept(visitor) on\nElementB, which calls visitElementB(this) on the visitor that \"visits\" ElementB (calls operationB()).\n\nClass diagram\nDetails\nThe visitor pattern requires a programming language that supports single dispatch, as common object-oriented languages (such as C++, Java, Smalltalk, Objective-C, Swift, JavaScript, Python and C#) do. Under this condition, consider two objects, each of some class type; one is termed the element, and the other is visitor.\nThe visitor declares a visit method, which takes the element as an argument, for each class of element. Concrete visitors are derived from the visitor class and implement these visit methods, each of which implements part of the algorithm operating on the object structure. The state of the algorithm is maintained locally by the concrete visitor class.\nThe element declares an accept method to accept a visitor, taking the visitor as an argument. Concrete elements, derived from the element class, implement the accept method. In its simplest form, this is no more than a call to the visitor's visit method. Composite elements, which maintain a list of child objects, typically iterate over these, calling each child's accept method.\nThe client creates the object structure, directly or indirectly, and instantiates the concrete visitors. When an operation is to be performed which is implemented using the Visitor pattern, it calls the accept method of the top-level element(s).\nWhen the accept method is called in the program, its implementation is chosen based on both the dynamic type of the element and the static type of the visitor. When the associated visit method is called, its implementation is chosen based on both the dynamic type of the visitor and the static type of the element, as known from within the implementation of the accept method, which is the same as the dynamic type of the element. (As a bonus, if the visitor can't handle an argument of the given element's type, then the compiler will catch the error.)\nThus, the implementation of the visit method is chosen based on both the dynamic type of the element and the dynamic type of the visitor. This effectively implements double dispatch. For languages whose object systems support multiple dispatch, not only single dispatch, such as Common Lisp or C# via the Dynamic Language Runtime (DLR), implementation of the visitor pattern is greatly simplified (a.k.a. Dynamic Visitor) by allowing use of simple function overloading to cover all the cases being visited. A dynamic visitor, provided it operates on public data only, conforms to the open/closed principle (since it does not modify extant structures) and to the single responsibility principle (since it implements the Visitor pattern in a separate component).\nIn this way, one algorithm can be written to traverse a graph of elements, and many different kinds of operations can be performed during that traversal by supplying different kinds of visitors to interact with the elements based on the dynamic types of both the elements and the visitors.\n\nC# example\nThis example declares a separate ExpressionPrintingVisitor class that takes care of the printing. If the introduction of a new concrete visitor is desired, a new class will be created to implement the Visitor interface, and new implementations for the Visit methods will be provided. The existing classes (Literal and Addition) will remain unchanged.\n\nSmalltalk example\nIn this case, it is the object's responsibility to know how to print itself on a stream. The visitor here is then the object, not the stream.\n\nGo\nGo does not support method overloading, so the visit methods need different names. A typical visitor interface might be\n\nJava example\nThe following example is in the language Java, and shows how the contents of a tree of nodes (in this case describing the components of a car) can be printed. Instead of creating print methods for each node subclass (Wheel, Engine, Body, and Car), one visitor class (CarElementPrintVisitor) performs the required printing action. Because different node subclasses require slightly different actions to print properly, CarElementPrintVisitor dispatches actions based on the class of the argument passed to its visit method. CarElementDoVisitor, which is analogous to a save operation for a different file format, does likewise.\n\nDiagram\nSources\nOutput\nVisiting front left wheel\nVisiting front right wheel\nVisiting back left wheel\nVisiting back right wheel\nVisiting body\nVisiting engine\nVisiting car\nKicking my front left wheel\nKicking my front right wheel\nKicking my back left wheel\nKicking my back right wheel\nMoving my body\nStarting my engine\nStarting my car\n\nCommon Lisp example\nSources\nOutput\n\"front-left-wheel\"\n\"front-right-wheel\"\n\"rear-left-wheel\"\n\"rear-right-wheel\"\n\"body\"\n\"engine\"\nkicking wheel \"front-left-wheel\" 42 times\nkicking wheel \"front-right-wheel\" 42 times\nkicking wheel \"rear-left-wheel\" 42 times\nkicking wheel \"rear-right-wheel\" 42 times\ndon't know how \"body\" and 42 should interact\nstarting engine \"engine\" 42 times\nkicking wheel \"front-left-wheel\" symbolically using symbol ABC\nkicking wheel \"front-right-wheel\" symbolically using symbol ABC\nkicking wheel \"rear-left-wheel\" symbolically using symbol ABC\nkicking wheel \"rear-right-wheel\" symbolically using symbol ABC\ndon't know how \"body\" and ABC should interact\nstarting engine \"engine\" symbolically using symbol ABC\n\nNotes\nThe other-object parameter is superfluous in traverse. The reason is that it is possible to use an anonymous function that calls the desired target method with a lexically captured object:\n\nNow, the multiple dispatch occurs in the call issued from the body of the anonymous function, and so traverse is just a mapping function that distributes a function application over the elements of an object. Thus all traces of the Visitor Pattern disappear, except for the mapping function, in which there is no evidence of two objects being involved. All knowledge of there being two objects and a dispatch on their types is in the lambda function.\n\nPython example\nPython does not support method overloading in the classical sense (polymorphic behavior according to type of passed parameters), so the \"visit\" methods for the different model types need to have different names.\n\nSources\nOutput\nAbstraction\nUsing Python 3 or above allows to make a general implementation of the accept method:\n\nOne could extend this to iterate over the class's method resolution order if they would like to fall back on already-implemented classes. They could also use the subclass hook feature to define the lookup in advance.\n\nRelated design patterns\nIterator pattern – defines a traversal principle like the visitor pattern, without making a type differentiation within the traversed objects\nChurch encoding – a related concept from functional programming, in which tagged union/sum types may be modeled using the behaviors of \"visitors\" on such types, and which enables the visitor pattern to emulate variants and patterns.\n\nSee also\nAlgebraic data type\nDouble dispatch\nMultiple dispatch\nFunction object\n\nReferences\nExternal links\n\nThe Visitor Family of Design Patterns at the Wayback Machine (archived October 22, 2015). Additional archives: April 12, 2004, March 5, 2002. A rough chapter from The Principles, Patterns, and Practices of Agile Software Development, Robert C. Martin, Prentice Hall\nVisitor pattern in UML and in LePUS3 (a Design Description Language)\nArticle \"Componentization: the Visitor Example by Bertrand Meyer and Karine Arnout, Computer (IEEE), vol. 39, no. 7, July 2006, pages 23-30.\nArticle A Type-theoretic Reconstruction of the Visitor Pattern\nArticle \"The Essence of the Visitor Pattern\" by Jens Palsberg and C. Barry Jay. 1997 IEEE-CS COMPSAC paper showing that accept() methods are unnecessary when reflection is available; introduces term 'Walkabout' for the technique.\nArticle \"A Time for Reflection\" by Bruce Wallace – subtitled \"Java 1.2's reflection capabilities eliminate burdensome accept() methods from your Visitor pattern\"\nVisitor Pattern using reflection(java).\nPerfectJPattern Open Source Project, Provides a context-free and type-safe implementation of the Visitor Pattern in Java based on Delegates.\nVisitor Design Pattern\n",
  "categories": [
    "Category:All articles needing additional references",
    "Category:Articles needing additional references from January 2022",
    "Category:Articles with example C++ code",
    "Category:Articles with example C Sharp code",
    "Category:Articles with example Java code",
    "Category:Articles with example Lisp (programming language) code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with example Smalltalk code",
    "Category:Articles with short description",
    "Category:CS1 maint: multiple names: authors list",
    "Category:Commons category link from Wikidata",
    "Category:Programming language comparisons",
    "Category:Short description is different from Wikidata",
    "Category:Software design patterns",
    "Category:Webarchive template wayback links"
  ],
  "archived_date": "20241221_183030",
  "source_url": "https://en.wikipedia.org/wiki/Visitor_pattern"
}