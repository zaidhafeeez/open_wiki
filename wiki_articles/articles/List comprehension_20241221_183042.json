{
  "title": "List comprehension",
  "summary": "A list comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists. It follows the form of the mathematical set-builder notation (set comprehension) as distinct from the use of map and filter functions.",
  "content": "---\ntitle: List comprehension\nurl: https://en.wikipedia.org/wiki/List_comprehension\nlanguage: en\ncategories: [\"Category:Articles with example Haskell code\", \"Category:Articles with example Python (programming language) code\", \"Category:Articles with example Racket code\", \"Category:Articles with example code\", \"Category:Articles with short description\", \"Category:Programming constructs\", \"Category:Short description is different from Wikidata\"]\nreferences: 0\nlast_modified: 2024-12-19T13:43:44Z\n---\n\n# List comprehension\n\n## Summary\n\nA list comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists. It follows the form of the mathematical set-builder notation (set comprehension) as distinct from the use of map and filter functions.\n\n## Full Content\n\nA list comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists. It follows the form of the mathematical set-builder notation (set comprehension) as distinct from the use of map and filter functions.\n\nOverview\nConsider the following example in mathematical set-builder notation.\n\n  \n    \n      \n        S\n        =\n        {\n        2\n        ⋅\n        x\n        ∣\n        x\n        ∈\n        \n          N\n        \n        ,\n         \n        \n          x\n          \n            2\n          \n        \n        >\n        3\n        }\n      \n    \n    {\\displaystyle S=\\{2\\cdot x\\mid x\\in \\mathbb {N} ,\\ x^{2}>3\\}}\n  \n\nor often\n\n  \n    \n      \n        S\n        =\n        {\n        2\n        ⋅\n        x\n        :\n        x\n        ∈\n        \n          N\n        \n        ,\n         \n        \n          x\n          \n            2\n          \n        \n        >\n        3\n        }\n      \n    \n    {\\displaystyle S=\\{2\\cdot x:x\\in \\mathbb {N} ,\\ x^{2}>3\\}}\n  \n\nThis can be read, \"\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n is the set of all numbers \"2 times \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n\" SUCH THAT \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n is an ELEMENT or MEMBER of the set of natural numbers (\n  \n    \n      \n        \n          N\n        \n      \n    \n    {\\displaystyle \\mathbb {N} }\n  \n), AND \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n squared is greater than \n  \n    \n      \n        3\n      \n    \n    {\\displaystyle 3}\n  \n.\"\nThe smallest natural number, x = 1, fails to satisfy the condition x2>3 (the condition 12>3 is false) so 2 ·1 is not included in S. The next natural number, 2, does satisfy the condition (22>3) as does every other natural number. Thus x consists of 2, 3, 4, 5... Since the set S consists of all numbers \"2 times x\" it is given by S = {4, 6, 8, 10,...}. S is, in other words, the set of all even numbers greater than 2.\nIn this annotated version of the example:\n\n  \n    \n      \n        S\n        =\n        {\n        \n          \n            \n              \n                2\n                ⋅\n                x\n              \n              ⏟\n            \n          \n          \n            \n              \n                output expression\n              \n            \n          \n        \n        ∣\n        \n          \n            \n              x\n              ⏟\n            \n          \n          \n            \n              \n                variable\n              \n            \n          \n        \n        ∈\n        \n          \n            \n              \n                N\n              \n              ⏟\n            \n          \n          \n            \n              \n                input set\n              \n            \n          \n        \n        ,\n         \n        \n          \n            \n              \n                \n                  x\n                  \n                    2\n                  \n                \n                >\n                3\n              \n              ⏟\n            \n          \n          \n            \n              \n                predicate\n              \n            \n          \n        \n        }\n      \n    \n    {\\displaystyle S=\\{\\underbrace {2\\cdot x} _{\\color {Violet}{\\text{output expression}}}\\mid \\underbrace {x} _{\\color {Violet}{\\text{variable}}}\\in \\underbrace {\\mathbb {N} } _{\\color {Violet}{\\text{input set}}},\\ \\underbrace {x^{2}>3} _{\\color {Violet}{\\text{predicate}}}\\}}\n  \n\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n is the variable representing members of an input set.\n\n  \n    \n      \n        \n          N\n        \n      \n    \n    {\\displaystyle \\mathbb {N} }\n  \n represents the input set, which in this example is the set of natural numbers\n\n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n        >\n        3\n      \n    \n    {\\displaystyle x^{2}>3}\n  \n is a predicate expression acting as a filter on members of the input set.\n\n  \n    \n      \n        2\n        ⋅\n        x\n      \n    \n    {\\displaystyle 2\\cdot x}\n  \n is an output expression producing members of the new set from members of the input set that satisfy the predicate expression.\n\n  \n    \n      \n        {\n        }\n      \n    \n    {\\displaystyle \\{\\}}\n  \n braces indicate that the result is a set\n\n  \n    \n      \n        ∣\n      \n    \n    {\\displaystyle \\mid }\n  \n \n  \n    \n      \n        ,\n      \n    \n    {\\displaystyle ,}\n  \n the vertical bar is read as \"SUCH THAT\". The bar and the colon \":\" are used interchangeably.\ncommas separate the predicates and can be read as \"AND\".\nA list comprehension has the same syntactic components to represent generation of a list in order from an input list or iterator:\n\nA variable representing members of an input list.\nAn input list (or iterator).\nAn optional predicate expression.\nAnd an output expression producing members of the output list from members of the input iterable that satisfy the predicate.\nThe order of generation of members of the output list is based on the order of items in the input.\nIn Haskell's list comprehension syntax, this set-builder construct would be written similarly, as:\n\nHere, the list [0..] represents \n  \n    \n      \n        \n          N\n        \n      \n    \n    {\\displaystyle \\mathbb {N} }\n  \n, x^2>3 represents the predicate, and 2*x represents the output expression.\nList comprehensions give results in a defined order (unlike the members of sets); and list comprehensions may generate the members of a list in order, rather than produce the entirety of the list thus allowing, for example, the previous Haskell definition of the members of an infinite list.\n\nHistory\nThe existence of related constructs predates the use of the term \"List Comprehension\". The SETL programming language (1969) has a set formation construct which is similar to list comprehensions. E.g., this code prints all prime numbers from 2 to N:\n\nprint([n in [2..N] | forall m in {2..n - 1} | n mod m > 0]);\n\nThe computer algebra system AXIOM (1973) has a similar construct that processes streams.\nThe first use of the term \"comprehension\" for such constructs was in Rod Burstall and John Darlington's description of their functional programming language NPL from 1977. In his retrospective \"Some History of Functional Programming Languages\", David Turner recalls:\n\nNPL was implemented in POP2 by Burstall and used for Darlington’s work on program transformation (Burstall & Darlington 1977). The language was first order, strongly (but not polymorphically) typed, purely functional, call-by-value. It also had “set expressions” e.g.\nsetofeven (X)  <=  <:x : x in X & even(x):>}}\nIn a footnote attached to the term \"list comprehension\", Turner also notes\n\nI initially called these ZF expressions, a reference to Zermelo–Fraenkel set theory — it was Phil Wadler who coined the better term list comprehension.\nBurstall and Darlington's work with NPL influenced many functional programming languages during the 1980s, but not all included list comprehensions. An exception was Turner's influential, pure, lazy, functional programming language Miranda, released in 1985. The subsequently developed standard pure lazy functional language Haskell includes many of Miranda's features, including list comprehensions.\nComprehensions were proposed as a query notation for databases and were implemented in the Kleisli database query language.\n\nExamples in different programming languages\nSimilar constructs\nMonad comprehension\nIn Haskell, a monad comprehension is a generalization of the list comprehension to other monads in functional programming.\n\nSet comprehension\nThe Python language introduces syntax for set comprehensions starting in version 2.7. Similar in form to list comprehensions, set comprehensions generate Python sets instead of lists.\n\nRacket set comprehensions generate Racket sets instead of lists.\n\nDictionary comprehension\nThe Python language introduced a new syntax for dictionary comprehensions in version 2.7, similar in form to list comprehensions but which generate Python dicts instead of lists.\n\nRacket hash table comprehensions generate Racket hash tables (one implementation of the Racket dictionary type).\n\nParallel list comprehension\nThe Glasgow Haskell Compiler has an extension called parallel list comprehension (also known as zip-comprehension) that permits multiple independent branches of qualifiers within the list comprehension syntax.\nWhereas qualifiers separated by commas are dependent (\"nested\"), qualifier branches separated by pipes are evaluated in parallel (this does not refer to any form of multithreadedness: it merely means that the branches are zipped).\n\nRacket's comprehensions standard library contains parallel and nested versions of its comprehensions, distinguished by \"for\" vs \"for*\" in the name. For example, the vector comprehensions \"for/vector\" and \"for*/vector\" create vectors by parallel versus nested iteration over sequences. The following is Racket code for the Haskell list comprehension examples.\n\nIn Python, we could do as follows:\n\nIn Julia, practically the same results can be achieved as follows:\n\nwith the only difference that instead of lists, in Julia, we have arrays.\n\nXQuery and XPath\nLike the original NPL use, these are fundamentally database access languages.\nThis makes the comprehension concept more important, because it is computationally infeasible to retrieve the entire list and operate on it (the initial 'entire list' may be an entire XML database).\nIn XPath, the expression:\n\nis conceptually evaluated as a series of \"steps\" where each step produces a list and the next step applies a filter function to each element in the previous step's output.\nIn XQuery, full XPath is available, but FLWOR statements are also used, which is a more powerful comprehension construct.\n\nHere the XPath //book is evaluated to create a sequence (aka list); the where clause is a functional \"filter\", the order by sorts the result, and the <shortBook>...</shortBook> XML snippet is actually an anonymous function that builds/transforms XML for each element in the sequence using the 'map' approach found in other functional languages.\nSo, in another functional language the above FLWOR statement may be implemented like this:\n\nLINQ in C#\nC# 3.0 has a group of related features called LINQ, which defines a set of query operators for manipulating object enumerations.\n\nIt also offers an alternative comprehension syntax, reminiscent of SQL:\n\nLINQ provides a capability over typical list comprehension implementations. When the root object of the comprehension implements the IQueryable interface, rather than just executing the chained methods of the comprehension, the entire sequence of commands are converted into an abstract syntax tree (AST) object, which is passed to the IQueryable object to interpret and execute.\nThis allows, amongst other things, for the IQueryable to\n\nrewrite an incompatible or inefficient comprehension\ntranslate the AST into another query language (e.g. SQL) for execution\n\nC++\nC++ does not have any language features directly supporting list comprehensions but operator overloading (e.g., overloading |, >>, >>=) has been used successfully to provide expressive syntax for \"embedded\" query domain-specific languages (DSL). Alternatively, list comprehensions can be constructed using the erase-remove idiom to select elements in a container and the STL algorithm for_each to transform them.\n\nThere is some effort in providing C++ with list-comprehension constructs/syntax similar to the set builder notation.\n\nIn Boost. Range [1] library there is a notion of adaptors [2] that can be applied to any range and do filtering, transformation etc. With this library, the original Haskell example would look like (using Boost.Lambda [3] for anonymous filtering and transforming functions) (Full example):\nThis implementation uses a macro and overloads the << operator. It evaluates any expression valid inside an 'if', and any variable name may be chosen. It's not threadsafe, however. Usage example:\n\nThis implementation provides head/tail slicing using classes and operator overloading, and the | operator for filtering lists (using functions). Usage example:\n\nLanguage for Embedded Query and Traversal (LEESA) is an embedded DSL in C++ that implements X-Path-like queries using operator overloading. The queries are executed on richly typed  xml trees obtained using xml-to-c++ binding from an XSD. There is absolutely no string encoding. Even the names of the xml tags are classes and therefore, there is no way for typos. If a LEESA expression forms an incorrect path that does not exist in the data model, the C++ compiler will reject the code.Consider a catalog xml.\n\nLEESA provides >> for XPath's / separator. XPath's // separator that \"skips\" intermediate nodes in the tree is implemented in LEESA using what's known as Strategic Programming. In the example below, catalog_, book_, author_, and name_ are instances of catalog, book, author, and name classes, respectively.\n\nSee also\nSet-builder notation\nThe SELECT statement together with its FROM and WHERE clauses in SQL\n\nNotes and references\nList Comprehension in The Free On-line Dictionary of Computing, Editor Denis Howe.\nWadler, Philip (1990). \"Comprehending Monads\". Proceedings of the 1990 ACM Conference on LISP and Functional Programming, Nice.\n\nExternal links\nSQL-like set operations with list comprehension one-liners in the Python Cookbook\nDiscussion on list comprehensions in Scheme and related constructs\nList Comprehensions across languages\n\nAxiom\nAxiom stream examples\n\nClojure\nClojure API documentation - for macro\n\nCommon Lisp\nImplementation of a Lisp comprehension macro by Guy Lapalme\n\nHaskell\nThe Haskell 98 Report, chapter 3.11 List Comprehensions.\nThe Glorious Glasgow Haskell Compilation System User's Guide, chapter 7.3.4 Parallel List Comprehensions.\nThe Hugs 98 User's Guide, chapter 5.1.2 Parallel list comprehensions (a.k.a. zip-comprehensions).\n\nOCaml\nOCaml Batteries Included\nLanguage extensions introduced in OCaml Batteries Included\n\nPython\nThe Python Tutorial, List Comprehensions.\nPython Language Reference, List displays.\nPython Enhancement Proposal PEP 202: List Comprehensions.\nPython Language Reference, Generator expressions.\nPython Enhancement Proposal PEP 289: Generator Expressions.\n",
  "categories": [
    "Category:Articles with example Haskell code",
    "Category:Articles with example Python (programming language) code",
    "Category:Articles with example Racket code",
    "Category:Articles with example code",
    "Category:Articles with short description",
    "Category:Programming constructs",
    "Category:Short description is different from Wikidata"
  ],
  "archived_date": "20241221_183042",
  "source_url": "https://en.wikipedia.org/wiki/List_comprehension"
}